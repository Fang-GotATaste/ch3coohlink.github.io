const body = document.body; body.innerHTML = ""
$.store = idb(assign(scope($), { name: "envjs" }))
css("body", { margin: 0 })
style(body, { paddingBottom: "50%" })

const preload = '{"global-state-location":[{"v":"const mktag = t => $[t] = (...a) => dom({tag:t, child:a})\\n\\"h1 p br pre b\\".split(\\" \\").forEach(mktag)\\nstyle(document.documentElement, {width:\\"50%\\"})\\nstyle(document.body, {margin:8})\\ncss(\\".right\\",{ textAlign:\\"right\\", marginRight:10 })\\ncss(\\"button\\", {verticalAlign:\\"bottom\\"})\\n\\nconst toggle = () => style(exd0, {height:(e0open=!e0open)?0:10000})\\n$.exb0 = dom({tag:\\"button\\", child:\\"点我展开/收起隐藏内容\\", onclick: toggle})\\n$.exd0 = dom({innerHTML:\\"假设我要把这段文本写上一千遍\\".repeat(1000)+\\"<br>你看用js写就很容易吧\\"})\\n$.e0open = false, toggle(), style(exd0, {overflow:\\"hidden\\", transition:\\"all 1s ease-in-out\\"})\\n\\nelm(document.body, {child:[ h1(\\"文学编程实践2\\"),\\ndom({tag:\\"h3\\", child:\\"——关于如何分解软件，单独开发，分别测试，并将组件合成为整体的艺术\\", class:\\"right\\"}),\\ndom({tag:\\"p\\", child:\\"幻想软件研究@2022\\", class:\\"right\\"}),\\n\\"首先，让我解释一下这个页面的功能，这是一个沙盒环境，左边是编辑器，右边是对应的页面。\\", br(),\\n\\"沙盒环境意味着你在js里做的操作不会影响到沙盒之外的东西，就像在一个iframe里那样（虽然实际上不是iframe）。\\", br(), br(),\\n\\"这样一个工具，它的一种简单的应用是写文章，就像我现在做的一样。\\", br(),\\n\\"使用js操作dom，编写样式，充分运用浏览器提供的排版功能。\\", br(),\\n\\"实际上，还不止于此，你可以使用js简化许多重复的文本编辑操作。\\", br(),\\n\\"（这里有一个很笨的例子，只要理解到我的意思就好：\\", exb0, \\"）\\", exd0, br(),\\n\\"不过编写文档这并不是这篇文章的主题，我想讨论的是一个更个人的问题:\\", br(),\\nb(\\"到底有没有一种理性的软件编写方式？\\"), br(),\\n\\"我不想讨论现有的软件工程实践，我只谈谈我心目中理想的软件开发应该是什么样的。\\", br(),\\n\\"任何程序都是从小发展到大的，再庞大的程序，也是在个人能够理解的尺度下被修改的（只要还是由人类来进行编程），这个尺度是我们能力的边界。\\", br(),\\n\\"这意味着对于某一个具体的软件功能，虽然它的实现可能依赖了非常复杂的基础库或者其他组件，但是这个功能本身的设计一定是简单的，因为我们必须把它的整个设计放在一个人的大脑里。\\", br(),\\n\\"应该存在一种手段，让我们可以从一个代码库中提取出我们当前真正关心的部分，告诉其他人（以及我们自己），对于当前的问题，我们设计了怎样的解决方案，以及这个解决方案是如何被转换为代码的。\\", br(),\\n\\"不难想象，一旦这样的工具变为现实，那么对于任意的一个软件设计，我们可以轻易为读者提供大量的可操作实例，让读者亲自修改，参与到软件的构建过程中来，这是现有的任何软件开发工具所不具备的能力。\\", br(),\\nbr(), \\"这篇文章将尝试如何从最简单的工具出发（也就是现在这个沙盒环境），构造出一套能够实现这一愿景的工具。\\"]})"},{"v":"style(document.documentElement, {width:\\"50%\\"}), style(document.body, {margin:8})\\nelm(document.body, {child:[\\"这个程序会打印当前网页的内存用量：\\", $.sw = dom({tag:\\"span\\"}), \\"MB\\", dom({tag:\\"br\\"}), \\"注意可能的内存泄漏😮\\"]})\\nconst upd = () => sw.innerText=(performance.memory.usedJSHeapSize/1024/1024).toFixed(1); setInterval(upd, 100), upd()"},{"v":"style(document.documentElement, {width:\\"50%\\"}), style(document.body, {margin:8})\\ncss(\\"pre\\", {fontFamily:\\"consolas\\", background:\\"#1d191d\\", color:\\"#cbd3d2\\"})\\ncss(\\"button\\", {verticalAlign:\\"bottom\\"})\\nconst mktag = t => $[t] = (...a) => dom({tag:t, child:a})\\n\\"h2 p br pre b\\".split(\\" \\").forEach(mktag)\\nconst a = (u, ...child) => elm(dom({tag:\\"a\\", child, href:u}), ()=>{})\\n\\nconst ctx = new AudioContext(), ack = [], ackf = [], acknf = []\\nforin(ctx, (v, k) => (ack.push(k), (isfct(v)?ackf:acknf).push([k, v])))\\n\\nconst exp0 = () => {\\n  const osc = ctx.createOscillator()\\n  osc.frequency.value = 440\\n  osc.connect(ctx.destination)\\n  osc.start()\\n  osc.stop(ctx.currentTime + 1)\\n}\\n\\nelm(document.body, {child:[\\nh2(\\"选一个什么样的主题?\\"), \\"实际上什么主题都可以，在实际的编程需求的驱动下，我们很快就会遇到需要拓展编辑器功能的情况，到那个时候，我们再来讨论如何升级工具。\\", br(),\\n\\"既然什么都可以写，那么我选个人比较感兴趣的Web Audio作为接下来的编程主题。\\", br(), br(),\\na(\\"https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Audio_API\\", \\"Web Audio是什么？\\"), br(), br(),\\n\\"让我用new AudioContext()创建一个Web Audio上下文，它是一个这样的对象：\\", br(), br(),\\n`{ ${ack.join(\\", \\")} }`, br(), br(),\\n\\"可能有点太复杂了，让我们先忽略掉所有的函数。\\", br(), br(),\\n`{ ${acknf.map(([k, v]) => `${k}: ${v}`).join(\\", \\")} }`, br(), br(),\\n\\"可以看到里面有一些延迟，采样率相关的数据，以及destination，这个是最关键的，它代表了一个web audio节点网络的输出。\\", br(), br(),\\n\\"而函数里面有一大堆都是create开头的：\\", br(), br(),\\n\\"{ \\", ...ackf.map(([k], i) => dom({tag:\\"span\\", child:k + (i === ackf.length - 1 ? \\"\\" : \\", \\"),\\n  style:{color:k.startsWith(\\"create\\")?\\"#0b0\\":\\"\\"}})), \\" }\\", br(), br(),\\n\\"这些函数全部都是用来创建特定节点的，剩下的就只有三个事件触发器相关的函数，一个解码函数，以及几个状态控制函数，基本上从名字也能猜到它们的作用了。\\", br(), br(),\\n\\"让我们试着组装一个节点：\\", dom({tag:\\"button\\", child:\\"▶\\", onclick:()=>{exp0()}}), pre(fct2str(exp0)),\\n`创建节点，设置属性，连接到输出，播放，停止，基本上所有的节点都是按类似的模式进行操作的，区别只在于每个节点的属性各不相同。`, br(), br(),\\n\\"一种有趣的音频应用是写一个合成器，而这需要对合成出来的音色的属性有更深层的了解，所以让我们先做个波形显示器。\\",\\n]})"},{"v":"style(document.documentElement, {width:\\"50%\\"}), style(document.body, {margin:8})\\nconst mktag = t => $[t] = (...a) => dom({tag:t, child:a})\\n\\"h2 p br pre b\\".split(\\" \\").forEach(mktag)\\nconst onclick = () => {\\n  const r = initspeech2text(), lang = \\"zh-CN\\" // 修改这个字符串为zh-CN可以识别中文\\n  assign(r, { lang, interimResults: true, maxAlternatives: 1 })\\n  const s = () => trycatch(() => ($.tmp = dom({}, document.body), r.start()))\\n  const onresult = e => tmp.innerText = e.results[0][0].transcript\\n  assign(r, { onend: s, onresult }), s() }\\nelm(document.body, {child:[\\nh2(\\"一个简单的语音识别的例子\\"), \\"（**并非文章的主要内容**）\\",\\ndom({tag:\\"button\\", child:\\"点我开始语音识别\\", onclick }), br(),\\n\\"下面的内容是使用js的toString功能拿到的函数源码，也就是说实际执行的代码与我展示的代码的总是一致的：\\",\\npre(fct2str(onclick)), \\"由于一些实现上的原因，同时存在两个SpeechRecognition对象的话会导致页面非常卡顿，所以我在编辑器里先实现了一个initspeech2text函数，它会返回一个公用的SpeechRecognition对象，其余部分就和一般的js完全一致了。\\", br(), br(),\\n\\"语音识别出的内容显示在这里：\\"]})"},{"v":"style(document.documentElement, {width:\\"50%\\"}), style(document.body, {margin:8})\\ncss(\\"ul, ol\\", {margin:0, paddingLeft:\\"2em\\"})\\nconst mktag = t => $[t] = (...a) => dom({tag:t, child:a})\\n\\"h2 p br pre b\\".split(\\" \\").forEach(mktag)\\nconst updvoice = () => $.voices = s.getVoices()\\nconst s = assign(speechSynthesis, { onvoiceschanged: updvoice })\\nconst speak = t => (s.cancel(), s.speak(assign(\\n  new SpeechSynthesisUtterance(t), { onerror: log, voice: voices[vi] })))\\nupdvoice(); const vs={}; voices.forEach((v, i) => (vs[v.lang]??=[]).push((v.i = i, v)))\\nelm(document.body, {child:[ h2(\\"一个简单的文本朗读的例子\\"),\\n  \\"（**并非文章的主要内容**）使用speak函数朗读文本，可用的语音列表：\\", br(), $.ll=dom()]})\\nconst item = v => dom({ tag: \\"li\\", child: `${v.i}: ${v.name}` }); forin(vs, (v, k) =>\\n  elm(ll, { child: [br(), k + \\": \\", dom({ tag: \\"ul\\", child: v.map(item) })] }))\\n\\nconst vi = 0 // 用这个序号选择语音\\nspeak(``) // 想说的话写在这里"}]}'
store.def(preload)

const fct2str = (f, s = String(f)) => {
  const t = s.slice(s.indexOf("{") + 1, s.lastIndexOf("}"))
  const a = t.split(/\r?\n/); if (a[0] === "") a.shift()
  const n = a[0].match(/^[\s]+/)?.[0].length ?? 0
  return a.map(v => v.slice(n)).join("\r\n").trim()
}

const lh = 18, setth = t => style(t, { height: t.value.split(/\r?\n/).length * lh })
const editor = d => {
  let sdbx, r = dom({ style: { display: "flex" } }), onkeydown = e =>
    e.key.toLowerCase() === "s" && (e.ctrlKey || e.altKey) ? (e.preventDefault(), upd())
      : e.key.toLowerCase() === "n" && e.altKey ? splice(d.i + 1, 0, { v: "" })
        : e.key.toLowerCase() === "w" && e.altKey ? splice(d.i, 1) : 0
  const upd = () => trycatch(() => (d.v = t.value, save(), refresh(),
    style(t, { color: "" })), e => (style(t, { color: "red" }), panic(e)))
  const t = dom({ tag: "textarea", value: d.v, onkeydown })
  elm(t, { oninput: () => setth(t), spellcheck: false })
  style(t, { resize: "none", width: "calc(50% - 6px)", lineHeight: lh })
  style(t, { whiteSpace: "pre", overflow: "hidden", fontFamily: "consolas, courier" })
  const refresh = () => (sdbx?.destroy(), sdbx = sandbox(assign(scope($), { extra: { fct2str } })),
    r = elm(r, { child: [t, sdbx.document.documentElement], diff: true }),
    Function("$", `with($){\n${d.v}\n}`)(sdbx))
  setth(t), setTimeout(refresh), d.d = r; return d
}

$.save = () => store.set(gsl, data.map(({ v }) => ({ v })))
$.sync = () => elm(editors, { child: data.map(({ d }) => d), diff: true })
$.splice = (s, c, ...a) => (data.splice(s, c, ...a.map(editor)),
  data.length > 0 ? 0 : data.push(editor({ v: "" })),
  forrg(data.length, i => data[i].i = i), sync())
const gsl = "global-state-location"; store.get(gsl).then(v => (
  body.append($.editors = dom()), $.data = [], splice(0, 0, ...v ?? [])))