<h1>文学编程实践3</h1>
<div class="sub-title">——文学编程软件的设计与开发</div>
<div class="right">◆ ch3coohlink@2022</div>
###code
"纪念第三次尝试 2022/07/30"
###
不知不觉间7月份也要结束了，这个项目已经被搁置了挺长时间，想着差不多是时候重新开始，于是接着之前的进度写了一整天……<br>
啊！不行！无论如何都写不下去！到了这一步，必须承认之前的思路是有问题的。<br>
我尝试使用文学编程方法去编写文学编程工具，但在JavaScript的规则限制之下，这需要做很多不必要的妥协。<br>
人的精力是宝贵的，为这些无关紧要的细节浪费时间实在不值得，所以我选择再次推到重来，虽然这么说，但前两次尝试所积累下来的经验还是很有价值的，现在的我比以往任何时候都更专注于有价值的目标，我有这种感觉。<br>
失败是成功之母，让我再尝试一次。<br>
<div class="spbar"></div>
<h2>刷新定位</h2>
在编辑这篇文档的时候，会遇到一个问题就是每次刷新文档都会回到文本最开始的位置，这里简单的使用一个脚本在文档开始加载之后的200ms将文档定位到一个指定的位置上。
###code
setTimeout(() => {
  const html = document.documentElement
  html.scroll(0, html.scrollHeight)
}, 400)
###
<div class="spbar"></div>
<h2>起点</h2>
现在你看到的这篇文档，是用一种这样的手法写成的：<br>
我编写了一个文件，里面混合了文本段和代码段，然后用一段脚本去解析它。<br>
如果遇到文本段，那么将文本直接添加到页面的html文档当中。<br>
如果遇到代码段，那么首先将代码的文本放到html文档里，接着执行这段代码。<br>
<div class="spbar"></div>
具体实现了一些什么功能呢？<br><br>
首先它实现了文章内容和代码的混编，这一点无需解释了。
<br>
其次它实现了一个全局名称空间：
###code
$ // $ 就是全局名称空间的名字
$.a = 1 // 这是定义a变量
$.a // 这样可以访问到a
a // 但其实不用$.也可以，因为我用了with代码块
###
全局名称空间的作用域是跨越代码段的：
###code
a // 这里仍然可以访问到a
delete $.a // 这样就可以删除a的定义，之后再访问a会造成引用错误
###
再次它创建了一个独立的DOM环境，让每段代码可以在DOM中添加需要的元素：
###code
const p = document.createElement("div")
p.style.border = "black solid 1px"
p.style.textAlign = "center"
p.style.padding = "1em"
p.textContent = "这个元素存在于独立的dom环境里"
root.append(p)
###
<div class="spbar"></div>
实现其实非常简单，只要看了解析脚本就能明白（让我用一点代码把它打印在这里，不过并不是很建议读，因为它只是支持这篇文章运作的一个最小系统，而实际的系统要在这篇文章里完成）。<br>
###code
const p = document.createElement("pre")
let text = document.getElementById("bootscript").textContent
p.style.fontFamily = `consolas, monospace, Apple Color Emoji, Segoe UI Emoji`
p.style.border = "black solid 1px"
p.style.whiteSpace = "pre-wrap"
p.style.background = "none"
p.style.overflow = "hidden"
p.textContent = text
root.append(p)
###
我的计划是以这种机制作为起点，编写一个可用性更高的文学编程系统。<br>
这个系统的设计核心在于，它其实是一个文本的数据库，各种不同功能的文本被打上标签，在合适的地方被展示出来。
<div class="spbar"></div>
<h2>JS基础库</h2>
这一段包含一些非常基本的语言功能，读者可以跳过。<br>
一些类型相关函数：
###code
$.isnum = o => typeof o == "number", $.isfct = o => typeof o == "function"
$.isstr = o => typeof o == "string", $.isbgi = o => typeof o == "bigint"
$.isudf = o => o === undefined, $.isnth = o => isudf(o) || isnul(o)
$.isobj = o => !!o && typeof o == "object", $.isnul = o => o === null
$.isarr = Array.isArray, $.asarr = v => isarr(v) ? v : [v]
$.isnumstr = s => isstr(s) && !isNaN(Number(s))
###
调试工具:
###code
$.log = (v, ...a) => (console.log(v, ...a), a.length > 0 ? [v, ...a]: v)
###
杂项:
###code
$.bindall = o => {
  for(const k in o) {
    const v = o[k]
    isfct(v) ? o[k] = v.bind(o) : 0
  } return o
}
$.assign = Object.assign
$.dfrag = t => document.createRange().createContextualFragment(t)
$.panic = e => { throw e }
###
<div class="spbar"></div>
<h2>文本编辑</h2>
在开始这节内容之前，首先编写一个帮助函数，用于简化DOM元素的创建：
###code
// 内联样式辅助函数
$.style = (e, ...ss) => {
  for(const s of ss) {
    for(const k in s) {
      let v = s[k]; isnum(v) ? v = `${v}px` : 0
      if(e.style[k] !== v) { e.style[k] = v }
    }
  } return e
}
###code
const elm = document.createElement.bind(document)
$.dom = (o = {}, p, n = o.tag ?? "div") => {
  const e = elm(n); for(const k in o) {
    const v = o[k]; switch(k) {
      case "class": e.className = isarr(v) ? v.join(" ") : v ; break;
      case "child": e.append(...asarr(v)); break;
      case "style": style(e, ...asarr(v)); break;
      default: e[k] !== v ? e[k] = v : 0; break;
    }
  } if(p) { p.append(e) } return e
}
###
用例：
###code
root.append(dom({child:"和之前的例子一样的元素，代码是不是精炼了很多?", style:
  {border:"black solid 1px", textAlign:"center", padding:"1em"}}))
###
更多用法可以在后面的使用过程中看到。
<div class="spbar"></div>
之前提到，文学编程系统的本质是一个文本数据库，那么首先我们要录入文本。<br>
下面的代码实现了一个简单的文本编辑器，和默认的textarea有一些样式上的区别，并且会自动适应文本高度：
###code
const fit = e => (e.style.height = "auto", e.style.height = e.scrollHeight + "px")
const ta = dom({tag:"textarea", placeholder: "点击这里编辑文本",
  oninput: () => fit(ta), style: { boxSizing:"border-box",
    fontSize: "1em", resize: "none", overflow:"hidden", border:"black 1px solid",
    width:"100%", margin: "0.4em 0", padding: "0.2em 0.2em 0.3em 1em",
    fontFamily: `consolas, monospace, Apple Color Emoji, Segoe UI Emoji` } })
root.attachShadow({mode:"open"}).append(dfrag(`<style>textarea:focus {outline: none}</style>`), ta), fit(ta)
###
<div class="spbar"></div>
现在我们可以编辑一段文本了，但很明显，只有一段文本是不够的，我们需要设计一种机制进行大量文本片段的编辑<br>
像vscode这样的文本编辑器会有一种类似于浏览器标签的机制用来编辑不同的文件，但照搬这种设计未必适合文学编程。<br>
这是因为，文学编程的文本之间存在着很强的关联，我们需要同时修改所有这些文本。<br>
为了做到这一点，我们可以实现一个文本列表，允许用户添加/删除/修改这些文本。<br>
下面的伪代码描述了如何实现这个文本列表的GUI。<br>
###code
// 存在一个文本列表和一个DOM列表
const texts = [], doms = []
// 对于文本列表的所有变化，都要表现在DOM列表上
const update = () => {/*更新doms中每个元素的值*/}
// 当文本列表发生变化，调用update函数进行更新
###
这个更新的机制可以简陋也可以复杂。<br>
最简陋的情形毫无疑问是：对于每次文本列表的任何变化，都删掉所有的DOM元素并替换成新的。<br>
但现实中这样做不仅有性能上的问题，对于textarea这样具有一定自身状态的元素而言，也会破坏掉这些状态。<br>
所以这里我采用一种稍微复杂一些的策略，其基本概念是：快速比较列表中发生变化的部分，同时最小化对DOM的修改。<br>
具体实现还是要看代码，不过如果你已经理解了上面的更新机制的话，它的实现其实只是细节，跳过也可以。<br>
###code
// 这个函数用于找出数组开头和结尾相同的部分
$.cutheadtail = (a, b) => {
  let al = a.length, bl = b.length, l = Math.min(al, bl), s = 0, e = al, t = bl, x, y
  for (;;s++) { if (s >= l || a[s] !== b[s]) { break } }
  for (;;e--, t--) { if ((x = e - 1) <= s || (y = t - 1) <= s || a[x] !== b[y]) { break } }
  return [s, e, t]
}
###code
let d = () => { throw "duplication" }
$.simpdiff = (n, p, keeporder = true) => {
  let [s, e, t] = cutheadtail(n, p), o = new Map, r = new Set, w = []

  for(let i = s; i < e; i++) { let v = n[i]; o.has(v) ? d() : o.set(v, i) }
  for(let i = s; i < t; i++) { let v = p[i]; !o.has(v) ? w.unshift(i) : r.has(v) ? d() : r.add(v) }

  for(let i of w) { p.splice(i, 1) }
  for(let i = s; i < e; i++) { let v = n[i]; r.has(v) ? 0 : p.splice(i, 0, v) }

  if(keeporder) {
    w = []
    for(let i = s; i < e; i++){ let a = n[i], b = p[i]; a === b ? 0 : w.unshift([i, o.get(b), b]) }
    for(let [i] of w) { p.splice(i, 1) }
    w = w.sort(([, a], [, b]) => a - b)
    for(let [, i, v] of w) { p.splice(i, 0, v) }
  }
}
###code
// 为了将上述函数用在dom元素上，再做一层包装
//（注意到这里的splice并不具备完整功能，这是因为diff函数里只需要单独添加删除，我偷了一点懒）
$.domarr = (e, d = e.childNodes) => {
  const splice = (i, c, a) => c ? e.removeChild(d[i]) : e.insertBefore(a, d[i])
  return new Proxy({}, { get: (_, k) => k === "splice" ? splice : d[k] })
}
###
上面实现了一个diff函数，它的功能是输入两个数组，将第二个数组最小化修改成第一个数组（是的，这个功能完全不像diff，但我也没想到更好的名字了）。<br>
让我做一个例子演示它的用法（同时检验其正确性）：
###code
const list = [...new Array(25)].map((v, i) => i + 1)
const doms = list.map(i => dom({child:i, tag:"span"}))
const container = dom({child:doms, style:{display:"inline"}})
const bt = dom({child:"打乱", tag:"button", onclick:() => {
    const {random, ceil} = Math, r = n => ceil(random() * n)
    const ds = [...doms], l = r(ds.length), result = []
    for(let i = 0; i < l; i++) { // 产生一个随机长度，随机顺序的新DOM序列
      let c = r(ds.length) - 1
      result.push(ds[c]), ds.splice(c, 1)
    } const ca = domarr(container) // 对HTML元素使用前需要包装一下
    simpdiff(result, ca) // 默认保证顺序，如果不需要保证顺序那么多加一个参数false
    for(let i = 0; i < result.length; i++) { if(result[i] !== ca[i]) {throw "order wrong!"} }
  }})
root.attachShadow({mode:"open"}).append(dfrag(`<style>
button { margin: 0.1em; padding: 0 0.5em; border: gray 1px solid; border-radius: 0.1em; font-size: 1em; }
button:hover { background: #ddd; cursor: pointer; }
span { display: inline-block; margin: 0.1em; width: 2em; text-align: center; border: black 1px solid}
</style>`), bt, container)
###
<br>
如上所示，simpdiff完全符合我们对update函数的要求，不论数组发生了多大的变化，它都能保证数组顺序的正确性并尽可能少地破坏元素的状态。<br>
而在数组发生较小变化的情况下，它也能尽快找出发生变化的部分，不至于消耗过多的性能（对于一般的情况确实如此，但有一种最坏的情况是交换数组的头尾，那会导致对整个数组都进行完整的分析，不过就算是那样，复杂度也仍是O(n)，我暂时是不打算改进了）。<br>
<div class="spbar"></div>
回到对文本列表的实现上来，现在很容易实现一个随时响应变化的文本列表GUI：
###code
const nt = (text="") => ({text, elm:dom({tag:"span", child:text})})
const list = [nt("假设这是一个文本编辑器"), nt("假设这是另一个文本编辑器")]
const container = dom() // 每次列表发生变化，调用下面这一行就可以实现对文本列表的更新
simpdiff(list.map(v => v.elm), domarr(container))
root.attachShadow({mode:"open"}).append(dfrag(`<style>span { display: block; margin: 0.1em 0; width: 100%;
text-align: center; border: black 1px solid; box-sizing: border-box;}</style>`), container)
###
<br>
如果把这个例子里的假元素替换成真正的文本编辑器，并添加一些新建删除文本的功能，这个文本列表似乎就完成了。<br>
但，具体要怎么做？<br>
之前我们实现了一个文本编辑器，但它仅仅是一段代码，而非一个函数，没有办法把它嵌入到这里的文本列表中。<br>
只有当我们可以拿到对应的源码，我们才有机会把它创建成一个函数，要怎么做到这件事情呢？。<br>
其实现有的机制就足够完成这件事情了：我可以在html文档里用pre标签编写一段代码（并不会运行），那么在实际的代码段中就可以拿到它的文本，之后想要怎们运行它就可以由我们自由控制了。<br>
来实际尝试一下这个过程，这是一段不会自动运行的代码：
<pre id="test_load_code_0", class="test_load_code_0">$.a = 1</pre>
而这段代码将加载运行它：
###code
$.textbyid = id => document.getElementById(id).textContent
$.tofunc = src => new Function("$", `with($){${src}}return $`)

const result = tofunc(textbyid("test_load_code_0"))({})
root.append(dom({child:"上述代码将一个空的全局环境修改成了：" + JSON.stringify(result)}))
###
<div class="spbar"></div>
回到文本编辑器的情形，首先把代码拷贝过来，稍加修改，按上面的方法放在文档当中：
<pre id="text_editor_0" class="text_editor_1">$.text ??= ""
const fit = e => (e.style.height = "auto", e.style.height = e.scrollHeight + "px")
$.ta = dom({tag:"textarea", placeholder: "点击这里编辑文本", value: text,
  oninput: () => fit(ta), style: { boxSizing:"border-box",
    fontSize: "1em", resize: "none", overflow:"hidden", border:"black 1px solid",
    width:"100%", margin: "0", padding: "0.2em 0.2em 0.3em 1em",
    fontFamily: `consolas, monospace, Apple Color Emoji, Segoe UI Emoji` } })
root.append(dom({tag:"style", child:`textarea:focus {outline: none}`}), ta)
setTimeout(() => fit(ta))
</pre>
同样进行加载：
###code
$.texteditor = tofunc(textbyid("text_editor_0"))
texteditor(Object.create($))
texteditor(Object.create($))
###
可以看到成功创建了两个文本编辑器。<br>
不过有一点小问题，上面的文本编辑器代码设计的时候是运作在一个独立的dom环境当中的，而这个例子里的两个文本编辑器共用了同一个dom环境，由于文本编辑器里自带了一小段样式代码，也就是说同样的样式表存在两个，这虽然不算什么太大的问题，但考虑到解决起来也很简单，这里还是再完善一下：<br>
###code
$.obj = Object.create
$.exec = (f, rt, o = obj($)) => {
  o.root = rt.attachShadow?.({mode:"open"}) ?? rt
  f(o); return o
}
const div = dom(); root.append(div); exec(texteditor, div)
###
这样额外传入一个普通html元素就可以在其内部创建封闭的dom环境了。
<div class="spbar"></div>
现在可以完成文本列表了吗？让我们再尝试一次。
###code
const nt = (text="", elm=dom({ tag:"span" }), o=assign(obj($))) =>
  exec(texteditor, elm, assign(obj($), {text, elm}))
const list = [nt("这是一个文本编辑器"), nt("这是另一个文本编辑器")]
const container = dom() // 每次列表发生变化，调用下面这一行就可以实现对文本列表的更新
simpdiff(list.map(v => v.elm), domarr(container))
root.append(container)
###
很好！两个对应文本列表的文本编辑器被创建出来了，距离可用的文本列表又进了一步。<br>
<div class="spbar"></div>
下面让我们进一步思考一下如何实现添加删除文本的功能。<br>
首先第一个问题是，要怎么在每个文本编辑器内部增加添加删除按钮呢？<br>
而如果有了按钮，又要如何实现对文本列表本身的修改呢？<br>
这些问题本身要实现起来都是简单的，但是我希望有一种组合性更强的方案。<br>
具体来说，我不希望改动之前写好的文本编辑器的代码，而是只在它的基础上增加一些新的内容。<br>
要如何做到这一点？<br>
前面我们通过把代码放在html文档里，实现了对代码的加载和调用，那么现在我们要调用多段代码，也可以使用相同的方法。<br>
下面同样给出一个例子，下面的两个pre标签都具有名称为 "test_load_code_1" 的 class：
<pre class="test_load_code_1">$.a = 1</pre>
<pre class="test_load_code_1">$.b = a + 1</pre>
通过class获取标签内容，然后拼接为函数进行调用：
###code
const _tbc = name => [...document.getElementsByClassName(name)].map(v => v.textContent)
$.textbyclass = (...names) => [].concat(...names.map(v => _tbc(v)))
$.tofunc = src => new Function("$", "with($){ " +
  asarr(src).map(v => `{\n${v}\n}`).join(" ") + " }return $")

const result = tofunc(textbyclass("test_load_code_1"))({})
root.append(dom({child:"上述代码将一个空的全局环境修改成了：" + JSON.stringify(result)}))
###
<div class="spbar"></div>
回到上一小节的问题，为了拓展文本编辑器，我们首先给先前的文本编辑器代码加上一个className。<br>
接着编写几段具有相同className的拓展代码：
<pre class="text_editor_1">
// 添加删除按钮
style(ta, {minHeight:62}); root.append(dom({tag:"style", child:`
button:hover { background: #ddd; cursor: pointer; }
button {height:20px; font-size:16px; border:none;}`}))
const div = dom({ style:{display:"flex", flexFlow:"column",
  alignSelf:"stretch", userSelect:"none", border: "black 1px solid",
  borderLeft: "none", justifyContent: "space-between"} }, root)
$.addupbt = dom({tag:"button", child:"+"}, div)
$.delbt = dom({tag:"button", child:"⨉", style:{fontSize:10}}, div)
$.adddwbt = dom({tag:"button", child:"+"}, div)
</pre><pre class="text_editor_1">
// 拖拽条
const div = dom({style:{alignSelf:"stretch", background:"#eee", cursor:"grab",
  border:"black 1px solid", borderRight:"none", userSelect:"none"}})
dom({tag:"span", child:"≡", style:{padding:"0.2em",
  position:"relative", top:"calc(50% - 0.7em)"}}, div)
root.insertBefore(div, ta)
</pre>
再将它们组合起来：
###code
$.texteditor = tofunc(textbyclass("text_editor_1"))
exec(texteditor, dom({style:{display:"flex", margin:"0.4em 0"}}, root))
###
成功了！说明我们确实可以在不修改原本代码的情况下修改文本编辑器的外观。<br>
<div class="spbar"></div>
接下来尝试实现文本列表的行为。<br>
回想一下上面实现文本编辑器的过程，我们将文本编辑器实现为了一个组件，从而可以在其他代码环境中复用它。<br>
这里我希望将文本列表也实现为一个组件，所以仍然选择将代码写在HTML中进行调用：<br>
<pre class="text_editor_list_0">
$.newtext = (text="", elm = dom()) => (
  style(elm, {display:"flex", margin:"0.4em 0"}),
  exec(texteditor, elm, assign(obj($), {text, elm})))
$.list = []
$.update = () => {
  if(list.length === 0) { list.push(newtext("")) }
  for(let i = 0, l = list.length; i < l; i++) { list[i].order = i }
  simpdiff(list.map(v => v.elm), domarr(container)) }
$.add = (i, t = newtext()) => (list.splice(i, 0, t), update())
$.del = i => (list.splice(i, 1), update())
$.container = dom(); update(); root.append(container)
</pre>同时为编辑器添加一些简单的行为：<pre class="text_editor_1">
addupbt.onclick = () => add(order)
delbt.onclick = () => del(order)
adddwbt.onclick = () => add(order+1)
ta.addEventListener("input", () => $.text = ta.value)
</pre>
加载运行：
###code
$.texteditor = tofunc(textbyclass("text_editor_1"))
###code
$.textlist = tofunc(textbyclass("text_editor_list_0"))
const tl = exec(textlist, root, obj($))
tl.list[0].ta.value = tl.list[0].text = 
  `试试右边的按钮，从上至下分别是：\n1. 在上方新建文本\n2. 删除当前文本\n3. 在下方新建文本`
###
文本列表的基本功能已经完成了，试试看！<br>
<div class="spbar"></div>
<h2>阶段总结</h2>
上一节实现的程序功能并不复杂，但是我觉得已经展现了文学编程的流程以及一些核心概念。<br>
和Knuth的文学编程不同，在我的设计里，动态语言随时修改程序定义的能力才是文学编程得以实现的基础。<br>
依托这种能力，不断地编写小的例子程序，并按文本顺序更新程序定义，才是我所定义的文学编程的关键。<br>
分条列出一些核心理念：
<ul>
<li>利用动态语言特性，不断修改程序定义，实现功能的拓展</li>
<li>多写例子程序，多迭代，提升文档的交互价值</li>
<li>
  描述问题，描述设计目标，最后编码
  <ul><li>但编码完成之前不要做进一步设计</li></ul>
</li>
<li>程序的模块化，重视组合性</li>
  <ul>
    <li>
      从文本层面重新构造函数，从而取得比一般编程手段更高的组合性<br>
      （关于这一点后面会有更多的展示）
    </li>
  </ul>
</ul>
<div class="spbar"></div>
针对上一小节提出的核心理念，下面开始讨论工具的具体设计目标。<br>
<br>
从前文的编程中可以观察到，文本层面的重组是一个非常关键的功能。<br>
在这篇文档的实践当中，通过把代码编写在HTML文档中，使用className或id获得其内容，实现了对代码的重新组合。<br>
而前文又提到，文学编程系统本质上是一个文本数据库，在上述的实践里，就是用HTML文档充当了这个数据库。<br>
<br>
现在我思考的问题是：这种机制是否足够？<br>
设计新机制之前总是需要考虑，这种新机制是否能带来足够大的收益。<br>
如果要设计更完善的文本数据库，我需要能够举例出至少一个具体的使用场景，并对这种机制的优势进行论证。<br>
<br>
记录一个值得思考的场景：<br>
有时希望拓展一个class下的模块，而当前的模式就能够支持按对应class的出现顺序进行加载。<br>
比如说上面的文本编辑器那里，第一次加载text_editor_1这个模块的时候，和第二次加载的时候实际上加载出的代码是不一样的，第二次多了一条额外的代码。<br>
这使得很多时候我们可以不用删除原本代码就实现对模块中程序定义的修改，只需要在后面覆盖不需要的定义即可（虽然可能性能上这样不是最优的）。<br>
</ul>
<div class="spbar"></div>
额外列出一些可以改进的点：
<ul>
  <li>文档加载时不能正确恢复到上次阅读的位置
    <ul><li>需要手动记录阅读位置，等文档加载完成再手动恢复</li></ul>
  </li>
  <li>文档编写的顺序可能并非读者阅读最合适的顺序，应当允许将代码提取出来，重组为一个更合适的阅读顺序
    <ul>
      <li>甚至是允许非线性的阅读，比如文字冒险游戏式的阅读</li>
      <li>需要工具辅助重新排列文本</li>
    </ul>
  </li>
  <li>服务端代码也可以写在这个文档中，只需要在服务端添加一个监视本文件变化的脚本并持续刷新服务器即可</li>
  <li>为每个文本指定一个uuid，从而将文本组合为其他类型的数据结构</li>
  <li>代码折叠功能（甚至是按组折叠）</li>
  <li>为悬浮窗口提供一个更合适的设计（目前使用position:sticky实现）</li>
</ul>
<div class="spbar"></div>
<h2>拖拽系统</h2>
这个似乎并不值得单独拿出来作为一章，但我想尝试把章节分得更细一些。<br>
前面实现的文本列表，虽然有拖拽条，但并不能通过拖拽修改顺序。<br>
所以下面就来实现拖拽功能，但最好是先把问题想得抽象一点，先来试验一下，在浏览器中实现拖拽系统需要哪些机制。<br>
下面是一个列表：
<pre class="drag_demo_0">
const shd = dom({}, root).attachShadow({mode:"open"})
shd.append(dom({tag:"style", child: `span { display:inline-block; margin:0.2em;
  border:1px solid black; padding:0.5em; width:1.5em; text-align:center }`}))
shd.append(...[...Array(10)].map((_, i) =>
  dom({tag:"span", child:"ABCDEFGHIJKLMNOPQRSTUVWXYZ"[i%26]})))
</pre>
###code
tofunc(textbyclass("drag_demo_0"))(obj($))
###
<h2>服务器通信</h2>
下面将尝试将编程范围扩展到服务器端：
首先我们需要准备一个服务器脚本用于：
<ul>
<li>提供http静态文件服务器</li>
<li>加载ws库使后续可以运行websocket服务器</li>
<li>监听这篇文档的变化</li>
<li>提供全局变量 $</li>
<li>提供一个作用域不受每次服务器刷新影响的变量 _</li>
</ul>
这里同样将文件内容打印出来：
###code
const root = $.root
fetch(`./server.js`).then(p => p.text()).then(data => {
  root.append(dom({tag:"pre", style:{ background: "none",
    fontFamily : `consolas, monospace, Apple Color Emoji, Segoe UI Emoji`,
    border : "black solid 1px", whiteSpace : "pre-wrap", padding: "1em 2em",
  }, child: data}))
})
###
初始化一个WebSocketServer服务器（注意对持久化变量_的运用）:
###server
const _lg = console.log; $.log = (v, ...a) => (_lg(v, ...a), v)
###server
$.wss = _.wss ??= new ws.WebSocketServer({port: 9000})
if(_.wsf) { wss.removeListener("connection", _.wsf) }
$.cns = _.cns ??= new Set()
for(const c of cns) c.send("refresh"); cns.clear()
wss.on("connection", _.wsf = ws => {
  cns.add(ws)
  ws.on("message", d => $.onmessage?.(ws, d))
  ws.on("close", () => cns.delete(ws))
  ws.onerror = console.error
})
###
下面实现一个简单的利用websocket刷新页面的功能：
###code
$.ws = new WebSocket("ws://localhost:9000")
ws.addEventListener("message", e => {
  // if(e.data === "refresh") { location.reload() }
})
###
现在每次更新本文档都会同时刷新服务器和浏览器了。
<div class="spbar"></div>
<h2>新编辑器</h2>
<pre class = "code_editor_0">
$.fg = "#cbd3d2", $.bg = "#1d191d"
</pre>
<pre class = "code_editor_0">
const fit = e => (e.style.height = "auto", e.style.height = e.scrollHeight + "px")
$.ta = dom({ tag: "textarea", placeholder: "", style: {
  width: "100%", padding: "0.2em 0.2em 0.4em 1em", display: "block",
  boxSizing: "border-box", resize: "none", fontSize: "1em",
  fontFamily: "consolas, monospace, Apple Color Emoji, Segoe UI Emoji",
  overflow: "hidden", color: fg, background: bg, border: "none"
}, oninput: () => fit(ta), spellcheck: false })
root.append(ta), fit(ta)
</pre>
<pre class = "code_editor_0">
$.save = () => {}
ta.addEventListener("keydown", e => {
  if(e.key === "s" && e.ctrlKey)
    e.preventDefault(), save() })
</pre>
<pre class = "code_editor_0">
$.sandbox = dom({ class: "output",
  style:{border:"1px solid "+bg, borderTop: "none", padding: 5 }})
root.append(sandbox)
</pre>
<pre class = "code_editor_0">
$.exec = () => {
  sandbox.innerHTML = ""
  tofunc(ta.value)(assign({}, {root: sandbox})) }
$.save = () => exec()
</pre>
###code
//dom({tag:"style", innerText:`.output:empty { display: none; }`}, root)
###code
style(root, { padding: 5, border: "solid 1px black", margin: "8px 0" })
const ta = obj($)
tofunc(textbyclass("code_editor_0"))(ta)
ta.ta.value = `root.innerHTML = new Date().getTime()
// 按Ctrl-S可以运行代码。`
ta.exec()
###
上面的代码实现了一个非常简陋的单段代码执行环境。<br>
每次运行，都会创建一个新的运行环境（并刷新附带的DOM环境）
<div class="spbar"></div>
<pre class = "code_editor_list_0">
$.newtext = (text="") => (code_editor(assign(obj($),
 {text, root:dom({style:{marginBottom:5}}, root)})))
$.list = [], $.update = () => {
  if(list.length === 0) { list.push(newtext("")) }
  for(let i = 0, l = list.length; i < l; i++) { list[i].order = i }
  simpdiff(list.map(v => v.root), domarr(container)) }
$.add = (i, t = newtext()) => (list.splice(i, 0, t), update())
$.del = i => (list.splice(i, 1), update())
$.container = dom(); update(); root.append(container)
</pre>
###code 
style(root, { padding: 5, border: "solid 1px black",
  margin: "8px 0", paddingBottom: 0 })
$.code_editor = tofunc(textbyclass("code_editor_0"))
$.editor_list = tofunc(textbyclass("code_editor_list_0"))
const el = editor_list(obj($))
el.add(0)
el.list[0].ta.value = `root.innerHTML = new Date().getTime()`
el.list[1].ta.value = `root.innerHTML = new Date().getTime()`
el.list[0].exec()
el.list[1].exec()
###
一个简陋的代码列表实现。各个代码编辑器之间没有联系。
<div class="spbar"></div>
###code
$.fitta = e => (e.style.height = "auto", e.style.height = e.scrollHeight + "px")
###
编辑器：
<pre class = "code_editor_1">
$.fg = "#cbd3d2", $.bg = "#1d191d"
</pre>
<pre class = "code_editor_1">
$.ta = dom({ tag: "textarea", placeholder: "", style: {
  width: "100%", padding: "0.2em 0.2em 0.4em 1em", display: "block",
  boxSizing: "border-box", resize: "none", fontSize: "1em",
  fontFamily: "consolas, monospace, Apple Color Emoji, Segoe UI Emoji",
  overflow: "hidden", color: fg, background: bg, border: "none"
}, oninput: () => fitta(ta), spellcheck: false })
</pre>
<pre class = "code_editor_1">
$.save = exec
ta.addEventListener("keydown", e => {
  if(e.key === "s" && e.ctrlKey)
    e.preventDefault(), save() })
</pre>
<pre class = "code_editor_1">
$.sandbox = dom({ class: "output",
  style:{border:"1px solid "+bg, borderTop: "none", padding: 5 }})
</pre>
<pre class = "code_editor_1">
dom({child: [ta, sandbox]}, root)
dom({tag:"button", child:"+", onclick: ()=>add(order) }, root)
dom({tag:"button", child:"⨉", style:{fontSize:10}, onclick:()=>del(order) }, root)
dom({tag:"button", child:"+", onclick: ()=>add(order+1) }, root)
fitta(ta)
</pre>
列表：
<pre class = "code_editor_list_1">
$.tofunc = src => new Function("$", "root", `with($){\n${src}\n}return $`)
</pre>
<pre class = "code_editor_list_1">
$.exec = ($ = {}) => {
  for(const e of list) { e.sandbox.innerHTML = "" }
  for(const e of list) { tofunc(e.ta.value)($, e.sandbox) } }
</pre>
<pre class = "code_editor_list_1">
$.newtext = (text="") => (code_editor(assign(obj($),
 {text, root:dom({style:{marginBottom:5}}, root)})))
$.list = [], $.update = () => {
  if(list.length === 0) { list.push(newtext("")) }
  for(let i = 0, l = list.length; i < l; i++) { list[i].order = i }
  simpdiff(list.map(v => v.root), domarr(container)) }
$.add = (i, t = newtext()) => (list.splice(i, 0, t), update())
$.del = i => (list.splice(i, 1), update())
</pre>
<pre class = "code_editor_list_1">
$.container = dom(); update(); root.append(container)
</pre>
###code
style(root, { padding: 5, border: "solid 1px black",
  margin: "8px 0", paddingBottom: 0 })
$.code_editor = tofunc(textbyclass("code_editor_1"))
$.editor_list = tofunc(textbyclass("code_editor_list_1"))
const el = editor_list(obj($))
el.add(0)
el.list[0].ta.value = `root.innerHTML = new Date().getTime()`
el.list[1].ta.value = `root.innerHTML = new Date().getTime()`
el.exec()
###
以上实现了一个所有代码段共同刷新的编辑器（并添加了增删按钮）。在任何一个编辑窗口保存代码都会刷新整个文档流。
<div class="spbar"></div>
下面为代码编辑器实现一个保存机制。<br>
这里简单对indexedDB做一个封装，实现一个简单的存储机制。
<pre class = "indexedDB_warper_0">
$.name ??= "default", $.store ??= "default"
</pre>
<pre class = "indexedDB_warper_0">
$.dbp = new Promise((res, rej, r = indexedDB.open(name)) => (
  r.onsuccess = () => res(r.result),
  r.onerror = () => rej(r.error),
  r.onupgradeneeded = () => r.result.createObjectStore(store)))
</pre>
<pre class = "indexedDB_warper_0">
$.action = (type, cb) => dbp.then(db =>
  new Promise((r, j, t = db.transaction(store, type)) => (
    t.oncomplete = () => r(),
    t.onabort = t.onerror = () => j(t.error),
    cb(t.objectStore(store)))))
</pre>
<pre class = "indexedDB_warper_0">
$._ = null, $.ro = f => action("readonly", f), $.rw = f => action("readwrite", f)
</pre>
<pre class = "indexedDB_warper_0">
$.key = (r = _) => ro(s => s.getAllKeys().onsuccess = e => r = e.target.result).then(() => r)
$.val = (r = _) => ro(s => s.getAll().onsuccess = e => r = e.target.result).then(() => r)
$.get = (k, p = false, r = _) => ro(s => r = s.get(k)).then(() => r.result
  ?? fallback[k] ?? (p ? panic(`"${k}" not found on storage`) : void 0))
$.clr = () => rw(s => s.clear())
$.set = (k, v) => rw(s => s.put(v, k))
$.del = k => rw(s => s.delete(k))
$.def = json => $.fallback = JSON.parse(json)
</pre>
<pre class = "indexedDB_warper_0">
$.fallback = {}, $.tojson = async (...a) => {
  const ks = await key(), o = {}
  await Promise.all(ks.map(k => get(k).then(r => o[k] = r)))
  return JSON.stringify(o, ...a) }
</pre>
测试如下（如果出错，将会弹出警告提示）：
###code
$.indexdb = tofunc(textbyclass("indexedDB_warper_0"))
const idb = indexdb({})
idb.set("test_key", "test_value")
  .then(() => idb.get("test_key"))
  .then(v => v !== "test_value" ? alert("something wrong with idb") : 0)
###
<div class="spbar"></div>
接下来将保存功能实现到编辑器中，从而实现对代码的持久化保存：<br>
编辑器：
<pre class = "code_editor_2">
$.fg = "#cbd3d2", $.bg = "#1d191d"
</pre>
<pre class = "code_editor_2">
$.ta = dom({ tag: "textarea", placeholder: "", style: {
  width: "100%", padding: "0.2em 0.2em 0.4em 1em", display: "block",
  boxSizing: "border-box", resize: "none", fontSize: "1em",
  fontFamily: "consolas, monospace, Apple Color Emoji, Segoe UI Emoji",
  overflow: "hidden", color: fg, background: bg, border: "none"
}, oninput: () => fitta(ta), spellcheck: false, value: text })
</pre>
<pre class = "code_editor_2">
ta.addEventListener("keydown", e => {
  if(e.key === "s" && e.ctrlKey) save()
  else if(e.key === "e" && e.ctrlKey) exec() })
</pre>
<pre class = "code_editor_2">
$.refresh = () => {
  const p = sandbox; $.sandbox = dom({ class: "output", style:
    {border:"1px solid "+bg, borderTop: "none", padding: 5, overflow: "auto" } })
  p.parentNode.replaceChild(sandbox, p) }
</pre>
<pre class = "code_editor_2">
$.gettext = () => ta.value
</pre>
<pre class = "code_editor_2">
$.bw = "25px"
$.btstyle = {border:"none", userSelect:"none"}
style(root, {display:"flex"})
$.sandbox = dom()
style(dom({child: [ta, sandbox]}, root),
  {width: `calc(100% - ${bw})`, display: "inline-block"})
refresh()
$.buttons = dom({child:[
  dom({tag:"button", style:[btstyle, {fontSize:10}], child:"⨉", onclick:()=>del(order) }),
  dom({tag:"button", style:btstyle, child:"+↑", onclick: ()=>add(order) }),
  dom({tag:"button", style:btstyle, child:"+↓", onclick: ()=>add(order+1) })
].map(v => (v.setAttribute("tabindex", "-1"), v))}, root)
style(buttons, {width: bw, display: "inline-flex", flexDirection:"column"},
  {verticalAlign:"top", justifyContent: "space-between"},
  {border: "1px black solid", borderLeft: "none"})
fitta(ta)
</pre>
注意exec函数现在需要将setInterval等函数注册的回调删除，所以需要一个额外的函数帮助处理这个问题：<br>
（这些函数的封装远远不是完美的，只能说，符合正常范围内的用途）<br>
<pre class = "setTimeout_etc_1">
[$.a, $.b] = name.split(" "), delete $.name
$.d = new Set, $.r = window[a].bind(window), $.c = window[b].bind(window)
</pre>
<pre class = "setTimeout_etc_1">
if(a === "requestAnimationFrame") { // 暴力修复，如果回调太多就会泄露
  $.rm = (f, t) => {const i=r(f, t);if(d.size>10){d.clear()}d.add(i);return i}
} else { $.rm = (f, t) => { const i = r(f, t); d.add(i); return i } }
$.cm = i => (d.delete(i), c(i))
$.clear = () => { for(const i of [...d]) { cm(i) } }
</pre>
列表：<br>
<pre class = "code_editor_list_2">
$.sprefix = "code/"
$.save = () => idb.set(sprefix + article_key, list.map(e => e.gettext()))
</pre>
<pre class = "code_editor_list_2">
$.tofunc = (src, n) => new Function("$", `[${n}]`,
`with($){\n${src}\n}return $`)
</pre>
<pre class = "code_editor_list_2">
$.stos = "requestIdleCallback cancelIdleCallback, requestAnimationFrame cancelAnimationFrame, setTimeout clearTimeout, setInterval clearInterval".split(", ").map(sto)
$.stosname = [].concat(...stos.map($ => [$.a, $.b])).join(", ")
$.stosfunc = [].concat(...stos.map($ => [$.rm, $.cm]))
</pre>
<pre class = "code_editor_list_2">
$.env = () => ({})
$.exec = ($ = env()) => {
  clear(); for(const e of list) {
    let f, t = e.ta.value; try { 
      f = tofunc(t, "root, " + stosname)
      f($, [e.sandbox, ...stosfunc]) }
    catch (e) { console.error(t); throw e } } }
</pre>
<pre class = "code_editor_list_2">
$.clear = () => {
  for(const s of stos) { s.clear() }
  for(const e of list) { e.refresh() } }
</pre>
<pre class = "code_editor_list_2">
$.newtext = (text="") => (code_editor(assign(obj($),
 {text, root:dom({style:{marginBottom:5}}, root)})))
$.list = [], $.update = () => {
  if(list.length === 0) { list.push(newtext("")) }
  for(let i = 0, l = list.length; i < l; i++) { list[i].order = i }
  simpdiff(list.map(v => v.root), domarr(container)) }
$.add = (i, t = newtext()) => (list.splice(i, 0, t), update())
$.del = i => (list.splice(i, 1), update())
$.container = dom()
</pre>
<pre class = "code_editor_list_2">
root.append(container)
idb.get(sprefix + article_key).then((a = []) => {
  $.list = a.map(newtext), update(), $.onload?.() })
</pre>
顺便关闭一下页面的保存快捷键：
###code
document.documentElement.addEventListener("keydown", e =>
  e.ctrlKey && e.key === "s" ? e.preventDefault() :
  e.ctrlKey && e.key === "e" ? e.preventDefault() : 0)
###
然后对列表做实例化：
###code
style(root, { padding: 5, border: "solid 1px black",
  margin: "8px 0", paddingBottom: 0 })
$.idb = indexdb({ name: "ltjs" })
$.rawsto = tofunc(textbyclass("setTimeout_etc_1"))
$.sto = name => rawsto({ name })
$.code_editor = tofunc(textbyclass("code_editor_2"))
$.editor_list_raw = tofunc(textbyclass("code_editor_list_2"))
$.editor_list = (n = "default") => editor_list_raw(assign(obj($), { article_key: n }))
const el = editor_list()
el.onload = el.exec
###
终于，一个能用的编辑器！<br>
尽管有很多细节上的问题，但是它确实可以用来编辑代码了，现在的问题是，可以用它做到什么程度的编程？<br>
一个显而易见的事情是它不具备类似于上面提到的引用代码一类的功能，也就是说只能操作顶层环境变量。<br>
这是个非常大的限制，因为现在的编辑器就等价于一个js文件，和在vscode中编辑一个文件并无区别。<br>
也就是说我们仍未实现一个可以充分利用文学编程优势的编辑器。<br>
<div class="spbar"></div>
编程需要对代码进行良好的组织，而文学编程甚至对此更为严格。<br>
在前面的章节里我们实现了一种对代码的复用，也就是通过直接引用代码文本的方式将其封装为一个函数。<br>
但对于文学编程而言，还可以想象另一种形式的复用：<br>
除了把上文中的一个编辑器当作一篇“文档”，我们还可以把一篇文章当作一个包含了我们所需功能的包。<br>
在这个视角下，我们可以将每篇文章当作一个模块，将相关的功能实现在其中，并在其它文章中进行导入从而实现更复杂的功能。<br>
<br>
但是听起来其实和引用代码文本还挺像的？我正在思考这个问题，引用一篇文章中的变量和引用文本从而生成函数似乎并没有什么本质的区别，因为后者完全可以实现前者，但前者却不能实现后者，也就是说我们应该从更根本的功能入手。<br>
<br>
在前面的章节中，我们是直接将代码文本写在HTML文档流中，通过id和class获取标签，从而实现对代码文本的引用的。<br>
但不得不说，这种编辑方式体验非常差，因为会有很多形如&lt;pre class="xxx"&gt;的文本干扰阅读，令人难以定位实际要修改的代码位置。<br>
<br>
我想设计一种更适合编辑需要被引用的代码的编辑器。<br>
<br>
想想看，要引用代码，这和编辑代码唯一的区别就在于，被引用的段落需要有一个名字。<br>
这就好比每个文件都会有一个名字一样，在一般的编程语言里，我们使用类似于import "./xxx/xxxx.xxx"的命令导入文件，这就是在用一个唯一的名字（将整个路径看作一个名字）去引用一段数据。<br>
而在我的设计当中，你可以用一个函数加上被引用文档的名字获取到它的内容，从而生成对应的函数。<br>
至于是要导入其中的变量还是将其作为一个对象来使用，这可以之后进行调整。<br>
<br>
经过上面的分析，基本可以确定一个大的设计方向了，不过还有一些小问题，比如对于每个文档的名称问题，我们可以选择生成一个uuid，也可以让用户自己进行命名。究竟怎样设计合适呢，下面稍微分析一下两种选择的利弊：<br>
让用户自己命名的话，需要强制用户保证每个名字都是唯一的，在迭代一个模块时就会出现后标序号这样的情况。<br>
而生成uuid的话，名字的唯一性是有了保证，但用户在指定引用的模块使就会遇到一些麻烦，可能需要设计额外的工具帮助定位所需的模块。<br>
这样看来的话，选择实现上更简单的方案比较好。<br>
<br>
而且实际上，现在可以用一种非常原始的方式给文本命名，演示如下：
###code
style(root, { padding: 5, border: "solid 1px black", margin: "8px 0" })
$.n = "demo_rename_editor_0"
const el = editor_list(n)
el.env = () => ({ dom })
el.onload = el.exec
root.append(`这里加载了一段名为${n}的文档。`)
###
<br>
要引用文本也是很简单的，只要从对应的数据库用文本名称进行获取就可以了：
###code
$.prfc = "code/"
$.prfcd = "codedatabase/"
###code
const root = $.root; idb.get(prfc + n).then((t = []) =>
  root.append(...t.map(t => dom({child:t, tag:"pre"})),
  `上面的代码将打印名称为${n}的文档的内容`))
style(root, { padding: 5, border: "solid 1px black",
  margin: "8px 0", paddingTop: 0 })
###
<div class="spbar"></div>
下面为代码的保存与加载功能编写一个更正式的实现：
<pre class="code_management_0">
$.articles = new Map
$.check = n => articles.has(n)
$.save = (n, a) => (articles.set(n, a), idb.set(prfc + n, a).then(savedb))
$.savedb = () => idb.set(prfcd + loadname, [...articles.keys()])
$.load = n => articles.get(n)
$.append = n => idb.get(prfc + n).then(a => a ? articles.set(n, a) : 0)
</pre>
<pre class="code_management_0">
$.loadname ??= "default"
$.onloads = []
idb.get(prfcd + loadname).then((ns = []) => {
  Promise.all(ns.map(n => idb.get(prfc + n))).then(as => {
    as.forEach((a, i) => articles.set(ns[i], a))
    onloads.forEach(f => f()) }) })
</pre>
###code
$.tofunc = s => new Function("__PROTO__", "__APPEND__",
  "$ = Object.assign(Object.create(__PROTO__), __APPEND__)", "with($) { " +
  asarr(s).map(v => `{\n${v}\n}`).join(" ") + " } return $")
###code
$.codemana = tofunc(textbyclass("code_management_0"))
$.cm = codemana($); const root = $.root
style(root, { padding: 5, border: "solid 1px black", margin: "8px 0" })
cm.onloads.push((a = [...cm.articles.keys()]) =>
  root.append("当前代码库中有文档：", a.join(", "), `，共计${a.length}个项目。`))
###
<div class="spbar"></div>
将上述功能嵌入编辑器中：
<pre class = "code_editor_list_3">
$.save = () => cm.save(article_key, list.map(e => e.gettext()))
</pre>
<pre class = "code_editor_list_3">
$.tofunc = (src, n) => new AsyncFunction("$", `[${n}]`, `with($){\n${src}\n}return $`)
</pre>
<pre class = "code_editor_list_3">
$.stos = "requestIdleCallback cancelIdleCallback, requestAnimationFrame cancelAnimationFrame, setTimeout clearTimeout, setInterval clearInterval".split(", ").map(sto)
$.stosname = [].concat(...stos.map($ => [$.a, $.b])).join(", ")
$.stosfunc = [].concat(...stos.map($ => [$.rm, $.cm]))
</pre>
<pre class = "code_editor_list_3">
$.env = () => ({ require, loadsym })
$.exec = async ($ = env()) => {
  clear(); for(const e of list) {
    let f, t = e.ta.value; try {
      f = tofunc(t, "root, " + stosname)
      await f($, [e.sandbox, ...stosfunc]) }
    catch (e) { console.error(t); throw e } } }
</pre>
<pre class = "code_editor_list_3">
$.clear = () => {
  for(const s of stos) { s.clear() }
  for(const e of list) { e.refresh() } }
</pre>
<pre class = "code_editor_list_3">
$.newtext = (text="") => (code_editor(assign(obj($),
  {text, root:dom({style:{marginBottom:5}}, root)})))
$.update = () => {
  if(list.length === 0) { list.push(newtext("")) }
  for(let i = 0, l = list.length; i < l; i++) { list[i].order = i }
  simpdiff(list.map(v => v.root), domarr(container)) }
$.add = (i, t = newtext()) => (list.splice(i, 0, t), update())
$.del = i => (list.splice(i, 1), update())
$.container = dom()
</pre>
<pre class = "code_editor_list_3">
let a = cm.load(article_key)
if($.create & !a) a = []
if(!a) throw `load "${article_key}" failed.`
$.list = a.map(newtext)
root.append(container), update()
</pre>
###code
$.require = n => tofunc(cm.load(n))
$.loadsym = (n, $) => require(n)(null, null, $)
###code
$.AsyncFunction = (async () => {}).constructor
$.editor_list_raw = tofunc(textbyclass("code_editor_list_3"))
###code
const root = $.root, n = "basic"
root.append("下面将一系列基础代码写入编辑器中，并演示在另一个编辑器中进行导入：", dom({ class: "spbar" }))
cm.onloads.push(() => {
  editor_list_raw($, {root, article_key: n})
  root.append(dom({ class: "spbar" }), `名为${n}的文档已经写入，下面演示导入：`)
})
###code
const root = $.root; cm.onloads.push(() => {
  const el = editor_list_raw($, {root, article_key: "test_basic_0"})
  el.exec()
})
###
<div class="spbar"></div>
至此，编辑器到了一个可以发挥基本功能的阶段，因此下面我们开始在编辑器中重新实现编辑器：
###code
const root = $.root; cm.onloads.push(() => {
  const el = editor_list_raw($, {root, article_key: "code_editor_0", create: true})
})
###
编辑器列表：
###code
const root = $.root; cm.onloads.push(() => {
  const el = editor_list_raw($, {root, article_key: "editor_list_0", create: true})
})
###
包装setInterval等函数：
###code
const root = $.root; cm.onloads.push(() => {
  const el = editor_list_raw($, {root, article_key: "setTimeout_etc_0", create: true})
})
###
<br>
从目前组件的拆分来看，前面的组件都非常适合在编辑器中重新实现，但对于代码库这一组件而言，同时存在两个以上会导致逻辑上的混乱。<br>
这是因为该组件的内部存在独立的状态（保存了所有的代码），原本这样做是为了保证代码加载的API都是同步的，但现在在沙箱允许await的前提下，这样的设计就不是必要的了。<br>
为了不引起混乱，可以重新设计全异步的代码库，但目前而言，先简单将原本环境中的代码库实例导入就好。<br>
<br>
组装所有代码：
###code
const root = $.root; cm.onloads.push(() => {
  const el = editor_list_raw($, {root, article_key: "rewrite_editor_0", create: true})
  const { env } = el; el.env = () => assign(env(), { cm }); el.exec()
})