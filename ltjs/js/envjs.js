const body = document.body; body.innerHTML = ""
$.store = idb(assign(scope($), { name: "envjs" }))
css("body", { margin: 0 })
style(body, { paddingBottom: "50%" })

const preload = '{"global-state-location":[{"v":"const mktag = t => $[t] = (...a) => dom({tag:t, child:a})\\n\\"h1 p br pre b\\".split(\\" \\").forEach(mktag)\\nstyle(document.documentElement, {width:\\"50%\\"})\\nstyle(document.body, {margin:\\"1em\\"})\\ncss(\\".right\\",{ textAlign:\\"right\\", marginRight:10 })\\ncss(\\"button\\", {verticalAlign:\\"bottom\\"})\\n\\nconst toggle = () => style(exd0, {height:(e0open=!e0open)?0:10000})\\n$.exb0 = dom({tag:\\"button\\", child:\\"点我展开/收起隐藏内容\\", onclick: toggle})\\n$.exd0 = dom({innerHTML:\\"假设我要把这段文本写上一千遍\\".repeat(1000)+\\"<br>你看用js写就很容易吧\\"})\\n$.e0open = false, toggle(), style(exd0, {overflow:\\"hidden\\", transition:\\"all 1s ease-in-out\\"})\\n\\nelm(document.body, {child:[ h1(\\"文学编程实践2\\"),\\ndom({tag:\\"h3\\", child:\\"——关于如何分解软件，单独开发，分别测试，并将组件合成为整体的艺术\\", class:\\"right\\"}),\\ndom({tag:\\"p\\", child:\\"幻想软件研究@2022\\", class:\\"right\\"}),\\n\\"首先，让我解释一下这个页面的功能，这是一个沙盒环境，左边是编辑器，右边是对应的页面。\\", br(),\\n\\"沙盒环境意味着你在js里做的操作不会影响到沙盒之外的东西，就像在一个iframe里那样（虽然实际上不是iframe）。\\", br(), br(),\\n\\"这样一个工具，它的一种简单的应用是写文章，就像我现在做的一样。\\", br(),\\n\\"使用js操作dom，编写样式，充分运用浏览器提供的排版功能。\\", br(),\\n\\"实际上，还不止于此，你可以使用js简化许多重复的文本编辑操作。\\", br(),\\n\\"（这里有一个很笨的例子，只要理解到我的意思就好：\\", exb0, \\"）\\", exd0, br(),\\n\\"不过编写文档这并不是这篇文章的主题，我想讨论的是一个更个人的问题:\\", br(),\\nb(\\"到底有没有一种理性的软件编写方式？\\"), br(),\\n\\"我不想讨论现有的软件工程实践，我只谈谈我心目中理想的软件开发应该是什么样的。\\", br(),\\n\\"任何程序都是从小发展到大的，再庞大的程序，也是在个人能够理解的尺度下被修改的（只要还是由人类来进行编程），这个尺度是我们能力的边界。\\", br(),\\n\\"这意味着对于某一个具体的软件功能，虽然它的实现可能依赖了非常复杂的基础库或者其他组件，但是这个功能本身的设计一定是简单的，因为我们必须把它的整个设计放在一个人的大脑里。\\", br(),\\n\\"应该存在一种手段，让我们可以从一个代码库中提取出我们当前真正关心的部分，告诉其他人（以及我们自己），对于当前的问题，我们设计了怎样的解决方案，以及这个解决方案是如何被转换为代码的。\\", br(),\\n\\"不难想象，一旦这样的工具变为现实，那么对于任意的一个软件设计，我们可以轻易为读者提供大量的可操作实例，让读者亲自修改，参与到软件的构建过程中来，这是现有的任何软件开发工具所不具备的能力。\\", br(),\\nbr(), \\"这篇文章将尝试如何从最简单的工具出发（也就是现在这个沙盒环境），构造出一套能够实现这一愿景的工具。\\"]})"},{"v":"style(document.documentElement, {width:\\"50%\\"}), style(document.body, {margin:\\"1em\\"})\\nelm(document.body, {child:[\\"这个程序会打印当前网页的内存用量：\\", $.sw = dom({tag:\\"span\\"}), \\"MB\\", dom({tag:\\"br\\"}), \\"注意可能的内存泄漏😮\\"]})\\nconst upd = () => sw.innerText=(performance.memory.usedJSHeapSize/1024/1024).toFixed(1); setInterval(upd, 100), upd()\\n//elm(document.body, {child:[dom({tag:\\"br\\"}), \\"自页面启动开始的事件：\\", $.tm = dom({tag:\\"span\\"}), \\"s\\"]});\\n//($.f = () => (requestAnimationFrame(f), elm(tm, {innerText:(performance.now()).toFixed()})))()"},{"v":"style(document.documentElement, {width:\\"50%\\"}), style(document.body, {margin:\\"1em\\"})\\ncss(\\"pre\\", {fontFamily:\\"consolas\\", background:\\"#1d191d\\", color:\\"#cbd3d2\\"})\\ncss(\\"button\\", {verticalAlign:\\"bottom\\"})\\nconst mktag = t => $[t] = (...a) => dom({tag:t, child:a})\\n\\"h2 h3 p br pre b button\\".split(\\" \\").forEach(mktag)\\nconst a = (u, ...child) => elm(dom({tag:\\"a\\", child, href:u}), ()=>{})\\n\\nconst ctx = new AudioContext(), ack = [], ackf = [], acknf = []; let preosc\\nforin(ctx, (v, k) => (ack.push(k), (isfct(v)?ackf:acknf).push([k, v])))\\nconst anl = ctx.createAnalyser(), ank = []; forin(anl, (v, k) => ank.push([k, v]))\\nanl.connect(ctx.destination)\\n//anl.fftSize = 8192\\n\\ncss(\\".data\\", { overflowWrap: \\"anywhere\\", fontSize:10, margin:\\"1em 0\\" })\\nconst tdinfo = dom({ class:\\"data\\" }), cvsheight = 150\\nconst cvssty = { display:\\"block\\", width:\\"100%\\", height:cvsheight, margin:\\"1em 0\\" }\\nconst tdcvs = style(dom({tag:\\"canvas\\"}), cvssty)\\nconst fdcvs = style(dom({tag:\\"canvas\\"}), cvssty)\\n\\nconst exp0 = () => {\\n  const osc = ctx.createOscillator()\\n  osc.frequency.value = 440\\n  osc.connect(ctx.destination)\\n  osc.start()\\n  osc.stop(ctx.currentTime + 1)\\n}, exp1 = () => {\\n  const osc = ctx.createOscillator()\\n  osc.frequency.value = 440\\n  osc.connect(anl) // 改为连接到分析器节点\\n  osc.start()\\n  osc.stop(ctx.currentTime + 1)\\n}, exp2 = () => {\\n  const td = new Uint8Array(anl.frequencyBinCount)\\n  const draw = () => {\\n    requestAnimationFrame(draw)\\n    anl.getByteTimeDomainData(td)\\n    // 确保每个数字都以三位数显示\\n    const tdstr = \\"[\\" + [...td].map(v=>v.toString().padStart(3, \\"0\\")).join(\\",\\") + \\"]\\"\\n    elm(tdinfo, {innerText: tdstr})\\n  }\\n  draw()\\n}, sound = fr => {\\n  preosc?.stop()\\n  const osc = ctx.createOscillator()\\n  osc.connect(anl)\\n  osc.frequency.value = fr\\n  osc.start()\\n  osc.stop(ctx.currentTime + 1)\\n  preosc = osc\\n}\\nexp2()\\n\\nconst sndict = \\"A A# B C C# D D# E F F# G G#\\".split(\\" \\")\\nconst num2sn = (i, k = i%12, h = Math.floor(i/12)) => sndict[k] + (k > 2 ? h+1 : h)\\nconst mksd = i => sound(27.5*Math.pow(2, i / 12))\\n\\nelm(document.body, {child:[\\nh2(\\"选一个什么样的主题?\\"), \\"实际上什么主题都可以，在实际的编程需求的驱动下，我们很快就会遇到需要拓展编辑器功能的情况，到那个时候，我们再来讨论如何升级工具。\\", br(),\\n\\"既然什么都可以写，那么我选个人比较感兴趣的Web Audio作为接下来的编程主题。\\", br(), br(),\\na(\\"https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Audio_API\\", \\"Web Audio是什么？\\"), br(), br(),\\n\\"让我用new AudioContext()创建一个Web Audio上下文，它是一个这样的对象：\\", br(), br(),\\n`{ ${ack.join(\\", \\")} }`, br(), br(),\\n\\"可能有点太复杂了，让我们先忽略掉所有的函数。\\", br(), br(),\\n`{ ${acknf.map(([k, v]) => `${k}: ${v}`).join(\\", \\")} }`, br(), br(),\\n\\"可以看到里面有一些延迟，采样率相关的数据，以及destination，这个是最关键的，它代表了一个web audio节点网络的输出。\\", br(), br(),\\n\\"而函数里面有一大堆都是create开头的：\\", br(), br(),\\n\\"{ \\", ...ackf.map(([k], i) => dom({tag:\\"span\\", child:k + (i === ackf.length - 1 ? \\"\\" : \\", \\"),\\n  style:{color:k.startsWith(\\"create\\")?\\"#0b0\\":\\"\\"}})), \\" }\\", br(), br(),\\n\\"这些函数全部都是用来创建特定节点的，剩下的就只有三个事件触发器相关的函数，一个解码函数，以及几个状态控制函数，基本上从名字也能猜到它们的作用了。\\", br(), br(),\\n\\"让我们试着组装一个节点：\\", dom({tag:\\"button\\", child:\\"▶\\", onclick:exp0}), pre(fct2str(exp0)),\\n`创建节点，设置属性，连接到输出，播放，停止，基本上所有的节点都是按类似的模式进行操作的，区别只在于每个节点的属性各不相同。`, br(), br(),\\n\\"一种有趣的音频应用是合成器，要实现对合成音色的精细调整，我们需要一些基础的音频可视化工具，所以让我们先实现一个波形显示器和一个频谱分析器。\\", br(), br(),\\n\\"在Web Audio里，可以使用Analyser节点对音频数据进行分析，创建一个Analyser节点看看其中的内容：\\", br(), br(),\\n\\"{ \\", ...ank.map(([k, v], i) => dom({tag:\\"span\\", style:{color:isfct(v)?\\"#0b0\\":\\"\\"},\\n  child:k + (isfct(v)?\\"\\":`: ${v}`) + (i === ank.length - 1 ? \\"\\" : \\", \\") })), \\" }\\", br(), br(),\\n\\"同样有不少内容，我把函数属性用颜色标记了出来，还是挺简单的，四个用于获取分析数据的get函数，两个连接控制函数，三个事件绑定函数。\\",\\n\\"其中最关键的就是前面四个get函数，它们分别用于获取音频的频域信息和时域信息，让我们用requestAnimationFrame尝试打印出每帧获取的信息。\\",\\npre(fct2str(exp2)), tdinfo, \\"可以看到，当没有任何音频的时候，使用getByteTimeDomainData获取到的时域信息总是一个由128构成的数组。\\",\\nbr(), \\"现在，让我们把一个振荡器节点连接到分析器节点上，并播放一些声音：\\",\\ndom({tag:\\"button\\", child:\\"▶\\", onclick:() => exp1()}), pre(fct2str(exp1)),\\n\\"数组的内容发生了变化，说明音频的内容正确地通过了分析器，这很好。\\",\\n\\"不过，这还不能称之为一个很好的可视化，因为数字的内容变化得太快了，以至于我们根本不知道具体发生了什么。\\",\\n\\"更好的方式是将波形数据绘制到canvas：\\",\\n($.exp3 = (cvs, whichdata = \\"time\\") => {\\n  const length = anl.frequencyBinCount, ist = whichdata === \\"time\\"\\n  const td = new Uint8Array(length), ctx = cvs.getContext(\\"2d\\")\\n  const draw = () => {\\n    requestAnimationFrame(draw)\\n    anl[ist ? \\"getByteTimeDomainData\\" : \\"getByteFrequencyData\\"](td)\\n    const { width, height } = tdcvs, slice = width * 1.0 / length\\n    ctx.fillStyle = \\"#ccc\\", ctx.fillRect(0, 0, width, height)\\n    ctx.strokeStyle = \\"#111\\", ctx.beginPath()\\n    for (let i = 0; i < length; i++) {\\n      const v = (ist ? td[i] : 256 - td[i]) / 128\\n      const x = i * slice, y = v * (height-20) / 2 + 10\\n      ctx[i === 0 ? \\"moveTo\\" : \\"lineTo\\"](x, y)\\n    } ctx.stroke()\\n  }\\n  draw()\\n}, exp3(tdcvs, \\"time\\"), pre(fct2str(exp3))), \\"效果如下：\\", tdcvs,\\n\\"同理，绘制出频域信息：\\", (exp3(fdcvs, \\"frequency\\"), fdcvs), \\"用钢琴上的88键来尝试一下：\\", br(),\\n...maprg(88, i => dom({ tag:\\"button\\", innerText:num2sn(i), onpointerdown:() => mksd(i),\\n  onpointerenter: () => pointerdown ? mksd(i) : 0 })), br(), br(),\\n\\"看起来可视化可以正常工作了，但用来测试声音的键盘还有一些问题。\\",\\n\\"你也许已经注意到了，在每个音启动和结束的时候，会产生一些额外的噪音。\\",\\n\\"在波形图中也能观察到，当产生噪音时，波形就会出现截断，说明这个截断就是噪音产生的原因。\\", br(), br(),\\n\\"那么，有没有办法消除掉这个噪音呢？\\", br(),\\n\\"让我们分析一下，既然产生噪音的原因是波形出现截断，那么我们应该想办法让每个音的开始和结束尽可能平滑，也就是使音量大小呈现出这样的变化：\\", br(),\\ndom({tag:\\"svg\\", child:[\\ndom({tag:\\"text\\", child:\\"刚开始按键时过渡到最大音量\\", x:20, y:120}),\\ndom({tag:\\"text\\", child:\\"按住时维持音量\\", x:100, y:42}),\\ndom({tag:\\"text\\", child:\\"松开时逐渐衰减到音量为0\\", x:250, y:120}),\\ndom({tag:\\"text\\", fill:\\"green\\", child:\\"对于键盘上的每个音都这样操作\\", x:290, y:70}),\\ndom({tag:\\"polyline\\", fill:\\"none\\", stroke:\\"black\\",\\n  points:`50,100 100,50 200,50 250,100`}),\\ndom({tag:\\"polyline\\", fill:\\"none\\", stroke:\\"green\\", transform:\\"translate(30,0)\\",\\n  points:`50,100 100,50 200,50 250,100`}),\\ndom({tag:\\"polyline\\", fill:\\"none\\", stroke:\\"blue\\", transform:\\"translate(60,0)\\",\\n  points:`50,100 100,50 200,50 250,100`}),\\n], width:600}), br(), \\"使用gain节点很容易实现这样的效果：\\",\\n($.exp4 = (fr, st) => {\\n  const t = 0.01\\n  const osc = ctx.createOscillator()\\n  const gain = ctx.createGain()\\n\\n  osc.connect(gain)\\n  gain.connect(anl)\\n\\n  // 先将音量设为0，在0.01秒之内过渡到1\\n  gain.gain.value = 0\\n  gain.gain.linearRampToValueAtTime(1, ctx.currentTime + t)\\n\\n  osc.frequency.value = fr\\n  osc.start(st)\\n\\n  // 返回一个用于停止播放的函数\\n  return () => {\\n    const st = ctx.currentTime + t\\n    gain.gain.value = gain.gain.value\\n    gain.gain.linearRampToValueAtTime(0, st)\\n    setTimeout(() => gain.disconnect(), t*1000+10)\\n  }\\n}, $.keysound2 = {}, $.mksd2 = (i, t = ctx.currentTime) => {\\n  stpsd2(i)\\n  return keysound2[i] = exp4(27.5*Math.pow(2, i / 12))\\n}, $.stpsd2 = i => { keysound2[i]?.() }, pre(fct2str(exp4))), \\"测试一下：\\", br(),\\n...maprg(88, i => elm(button(num2sn(i)), {\\n  onpointerdown:() => mksd2(i),\\n  onpointerup:() => stpsd2(i),\\n  onpointerenter: () => pointerdown ? mksd2(i) : 0,\\n  onpointerleave: () => stpsd2(i),\\n})), br(), br(),\\n\\"从上面的例子可以看到，即使只设置一个很短的过渡时间，也能起到消除噪音的作用，说明这个过渡时间对于音频合成来讲非常重要。\\",\\ndom({class:\\"spbar\\"}),\\n\\"现在我们已经编写了一个非常简陋的合成器，可以通过按钮来弹一些简单的曲子了，为何不把这个过程自动化一下呢？\\", br(), br(),\\n\\"试着分析一下，如果想要自动化这个演奏的过程，我们就需要告诉程序在什么时间演奏什么音，我们可以使用文本来编码这些信息，就像这样：\\",\\npre(\\"C3 C3 G3 G3 A3 A3 G3\\\\n（小星星的第一句）\\\\n（你可能注意到这里面还没有编码节奏相关的信息，这个留到后面考虑）\\"),\\n\\"让我们按这个思路尝试设计一个文本形式音符的解析器（以及相应的音序器）：\\",\\n($.playsoundat = mksd2, $.exp5 = () => {\\n  const snarr = \\"A A# B C C# D D# E F F# G G#\\".split(\\" \\")\\n  const num2sn = (i, k = i%12, h = Math.floor(i/12)) => sndict[k] + (k > 2 ? h+1 : h)\\n  const sndct = {}; forrg(88, i => sndct[num2sn(i)] = i)\\n  const parse = i => i.trim().split(/\\\\s+/).map(v => v.toUpperCase())\\n    .map(v => v in sndct ? sndct[v] : panic(`unknown sound name: \\"${v}\\"`))\\n\\n  const bpm = 120, dt = 60 / bpm\\n  return (i, notes = parse(i)) => {\\n    let t = ctx.currentTime, stop\\n    const pollnote = () => {\\n      while(t <= ctx.currentTime + 0.1) {\\n        const n = notes.shift(); if(!n) { stop?.(); return }\\n        stop?.(), stop = playsoundat(n, t), t += dt // 停止上一个音，播放当前音\\n      } setTimeout(pollnote, 50)\\n    }; pollnote()\\n  }\\n}, $.pssd1 = exp5(), $.littlestar1 =\\n`c4 c4 g4 g4 a4 a4 g4 f4 f4 e4 e4 d4 d4 c4\\ng4 g4 f4 f4 e4 e4 d4 g4 g4 f4 f4 e4 e4 d4\\nc4 c4 g4 g4 a4 a4 g4 f4 f4 e4 e4 d4 d4 c4`, pre(fct2str(exp5))),\\n\\"用小星星测试一下这个简单的音序器：\\", elm(button(\\"▶\\"), {onclick: () => pssd1(littlestar1)}),\\nbr(), \\"或者是演奏你自定义的序列：\\", elm(button(\\"▶\\"), { onclick: () => trycatch(() => pssd1(sqsdta1.value)) }), br(),\\n$.sqsdta1 = dom({ tag: \\"textarea\\", value: littlestar1 }), br(), br(),\\n\\"为了进一步拓展音序器的功能，让我们仔细思考一下音序器的代码。现在这个音序器的基本逻辑是：\\", br(),\\nb(\\"当一个音应当发生在未来0.1s秒之内的时候，将这个音规划到web audio的发音队列里。\\"), br(),\\n\\"核心逻辑是没问题的，不过具体实现上还有一些不足：\\", br(),\\n\\"比如，我们对音符发生时间的计算是发生在pollnote的循环里的，实际上完全可以预先算出每个音符的启动时间。\\", br(),\\n\\"也就是说，我们应该把启动时间当作一个音符的核心属性。更进一步地，我们可以抽象出一个\\", b(\\"音频事件\\"), \\"的概念：\\", br(),\\n\\"它的数据中有两部分信息，\\", b(\\"一是事件发生的时间，二是对web audio上下文的操作。\\"), br(),\\n\\"也就是说，当每个音符发生时，我们需要把从启动开始到音符结束的所有音频操作都排进web audio的计划表。\\", br(),\\n\\"实际上，所有的音频操作都可以以这种形式被抽象出来，包括各种对属性的包络线操作，后面实现这些功能的时候，我们会看到这个抽象的简洁强大。\\", br(),\\ndom({class:\\"spbar\\"}),\\n\\"在上面的分析中，我们（至少在概念上）解决了音序器的设计问题，但是还有另一个很关键的部分，那就是用于编码演奏信息的语言。\\", br(),\\n\\"在上面的例子里，我写了一个非常简陋的描述语言，它只能匹配编码好的固定的88个音名，除此之外的任何东西都被视为错误。\\", br(),\\n\\"这样的一个语言，首先用户体验说不上有多好，更重要的是，它很难被拓展。\\", br(),\\n\\"我认为需要更正式地思考一下这个语言的设计问题，因此，对于web audio的探索暂告一段落，先让我们回到对文学编程的思考上。▯\\"\\n]})\\n\\nstyle(sqsdta1, { height: sqsdta1.value.split(/\\\\r?\\\\n/).length * 20 })\\ncss(\\"textarea\\", { width:\\"100%\\", lineHeight:20, fontSize:\\"1em\\", fontFamily:\\"consolas\\" })\\ncss(\\".spbar\\", {width:\\"calc(100% - 2em)\\", margin:\\"1em\\", height:1, backgroundColor:\\"black\\"})\\n\\naddEventListener(\\"resize\\", () => {\\n  tdcvs.width = tdcvs.clientWidth * devicePixelRatio\\n  tdcvs.height = cvsheight * devicePixelRatio\\n  fdcvs.width = tdcvs.clientWidth * devicePixelRatio\\n  fdcvs.height = cvsheight * devicePixelRatio\\n}); let pointerdown\\naddEventListener(\\"pointerdown\\", () => pointerdown = true)\\naddEventListener(\\"pointerup\\", () => pointerdown = false)"},{"v":"style(document.documentElement, {width:\\"50%\\"}), style(document.body, {margin:8})\\nconst mktag = t => $[t] = (...a) => dom({tag:t, child:a}), lh = 20\\n\\"h2 p br pre b ul ol li span div\\".split(\\" \\").forEach(mktag)\\n$.ta = (v = \\"\\") => dom({ tag: \\"textarea\\", spellcheck: false, value: v })\\n$.code = (v = \\"\\", e = true) => (\\n  isfct(v) ? (e ? setTimeout(v) : 0, v = fct2str(v)): 0, dom({ class: \\"code\\", innerText: v }))\\ncss(\\".spbar\\", {width:\\"calc(100% - 2em)\\", margin:\\"1em\\", height:1, backgroundColor:\\"black\\"})\\n\\nconst codefont = { lineHeight: lh, fontSize: \\"1em\\", fontFamily: \\"consolas\\", whiteSpace: \\"pre-wrap\\" }\\ncss(\\".code, .test\\", codefont, { background:\\"#1d191d\\", color:\\"#cbd3d2\\"},\\n  { margin: \\"0.2em 0\\", padding: \\"0.2em 0\\", paddingLeft: \\"2em\\" })\\ncss(\\".accident\\", {color:\\"red\\"})\\nstyle(document.body, { margin: \\"1em\\" }); css(\\"ul, ol\\", { margin: 0 })\\n\\nelm(document.body, {child:[\\nh2(\\"文学编程功能的阶段性总结\\"), \\"上面的文章积累了一些文学编程的案例，现在试着总结一下我从中理解到的东西：\\",\\nul(li(\\"在上面的例子中，我将文章的内容全部编码在DOM操作里，这样做的好处是可以在文章中编写任何程序，但是也造成了一些问题：\\",\\nul(li(\\"文章内容和程序的对应关系不明显，通常要在程序里进行一些定位才知道要在哪里修改对应的文章段落。\\"),\\n   li(\\"文章中插入的程序段与全局环境的联系完全没有给出。\\")),\\nli(\\"还有一些额外的想法：\\", ul(li(\\"上面的例子中实现了一个音频可视化的工具，我希望可以让它具有类似position:sticky的样式\\",\\n\\"，但是position:sticky需要父级容器本身存在scroll，和现在的设计并不兼容（也许要等实现完整的文档渲染器才能做得比较完美）。\\"),\\nli(\\"需要某种程度的组件编辑器，用于实现自定义标签（举例：上一段文章中写的数据可视化器，以及虚拟钢琴键盘都可以作为自定义标签）。\\"),\\nli(\\"文本编辑的体验太差了（永远的问题）。\\")),\\n))),\\n\\"这样总结了一下，看起来这些问题是有一些内在的重合的，如果我尝试去编写文本编辑器的话，说不定可以把好几个问题放在一起解决。\\", br(), br(),\\n\\"那么就开始编写文本编辑器。\\", dom({class:\\"spbar\\"}), \\"首先定义设计目标：\\", \\nul(li(\\"这个文本编辑器的设计目的是替换掉默认的textarea，所以不需要特别高级的文本编辑功能。\\"),\\n  li(\\"需要支持缩进，选择，可以的话支持一下多光标编辑。\\"),\\n  li(\\"在用户态完成文本编辑器所有代码的编写，也就是说左边的代码只负责编写文档，实际的功能要在右边的编辑器里完成。\\"),\\n  li(\\"将编辑器实现为自定义标签，测试创建作用域的流程。\\"),\\n  li(\\"完成编辑器之后设法替换掉左边的编辑器，逐渐提升整个工具的体验。\\")), dom({class:\\"spbar\\"}),\\n\\"接下来，确定一下运行代码的流程。\\",\\ncode(() => {\\n// $是全局空间的名字，由于js的一些限制，我们使用这种方式修改全局空间中的变量\\n$.sum = (a, b) => a + b\\n}),\\n\\"进行一些测试：\\", code(() => {\\n$.bs = b => b ? \\"✅\\" : \\"❌\\"\\n$.test = f => [span(bs(f())), \\" \\", String(f)]\\n// rs1是用来打印测试结果的标签的变量名\\nelm(rs1, {child:[ li(...test(() => sum(1, 1) === 2)),\\n  li(...test((a = Math.random(), b = Math.random()) => sum(a, b) === a + b)) ]})\\n}), \\"将测试结果打印出来：\\", $.rs1 = elm(ul(), {class:\\"test\\"}), dom({class:\\"spbar\\"}),\\n\\"现在，考虑一个最简单的文本编辑的情形——编辑单行文本：\\", br(),\\n\\"首先使用一个textarea监听用户的所有键盘输入:\\", br(),\\ncode(() => {\\nlet dkeys = new Set, ipt = {}\\nconst onkeydown = e => (dkeys.add(e.key), update())\\nconst onkeyup = e => (dkeys.delete(e.key), update())\\nconst oninput = e => (ipt = e, textarea.value = \\"\\")\\nconst update = () => elm(rs3, { innerHTML:\\"\\", child: [\\n  \\"当前输入内容：\\", ipt.data ?? \\"<空>\\", br(),\\n  \\"是否为IME：\\", bs(ipt.isComposing), br(),\\n  \\"当前按下的按钮：\\", dkeys.size === 0 ? \\"<空>\\" : [...dkeys].map(v => v === \\" \\" ? \\"Space\\" : v).join(\\" \\"),\\n]})\\nconst textarea = elm(ta(), { onkeydown, onkeyup, oninput, style:{display:\\"block\\"} })\\n// 将占位符rs2更换为textarea\\nswaptag(\\"\\", rs2, textarea)\\nupdate()\\n}),\\n\\"上面的代码将在这里创建一个textarea：\\", br(), $.rs2 = dom(),\\n$.rs3 = dom(), dom({class:\\"spbar\\"}),\\n\\"下一步，让我们实现文本显示以及光标：\\", br(),\\ncode(() => {\\nconst text = \\"0123456789\\".repeat(100)\\nelm(rs4, {child: [$.txt1 = div(text), $.csr1 = div()], style:{overflow:\\"hidden\\",\\n  width:\\"100%\\", position:\\"relative\\", boxSizing:\\"border-box\\"}, class:\\"code\\"})\\nstyle(csr1, {position:\\"absolute\\", width:2, height:lh, top:\\"0.2em\\", background:\\"#cbd3d2\\"})\\n}), \\"上面的代码生成了一段测试文本以及一个用于表示光标的div标签：\\", $.rs4 = dom(), br(),\\n\\"一个显而易见的问题是，由于我们不知道一段文本的具体宽度，因此无法实现对光标的移动。\\", br(),\\n\\"所以，我们需要某种测量文本长度的手段，一种方法是使用Range对象：\\",\\ncode(() => {\\nconst measure_range = () => {\\n  const sel = getSelection()\\n  if(!sel.rangeCount) { return }\\n  const range = sel.getRangeAt(0)\\n  const { width, height } = range.getBoundingClientRect()\\n  elm(rs5, {innerText: `当前选择区域的宽度为${width}，高度为${height}。`})\\n}\\nmeasure_range()\\naddEventListener(\\"pointermove\\", measure_range)\\n}), \\"上面的函数从当前窗口里的选择区域创建Range对象，从而获取其长宽：\\", rs5 = span(), br(),\\ndom({class: \\"accident\\", child: [\\n  \\"发生了意外：上面这段代码没有正常工作，只有在极少数的情况才能测量出结果，原因未知。\\", br(),\\n  \\"还有一个问题，由于获取range长宽的方法是getBoudingClientRect，也就是说，仅当测量的对象没有发生缩放时，测量结果才是正确的。\\", br(),\\n  \\"经测试，使用range测量字符宽度的codemirror编辑器在整个元素缩放之后，其光标位置会出现错误，这证明了上述想法。\\",\\n  \\"（monaco编辑器（vscode）没有这个问题，可能是没有使用range进行测量或者做了特殊处理。）\\" ]}), br(),\\n\\"由于上面的测量方法有一些问题，让我们换一种思路，使用canvas提供的measureText函数进行测量：\\", br(),\\ncode(() => {\\nconst cvs = dom({tag:\\"canvas\\"}), ctx = cvs.getContext(\\"2d\\")\\nconst _tw = t => ctx.measureText(t).width, cache = {}\\nconst tw = (t, f) => (cache[f] ??= {})[t] ?? (cache[f][t] = _tw(t))\\n$.rawtextwidth = (t, f) => (ctx.font !== f ? ctx.font = f : 0, _tw(t))\\n$.textwidth = (t, f) => (ctx.font !== f ? ctx.font = f : 0,\\n  [...t].map(c => tw(c, f)).reduce((p, v) => p + v, 0))\\n}), \\"写个测试程序：\\",\\ncode(() => {\\nconst {abs, random, floor} = Math, rtw = $.rawtextwidth, tw = $.textwidth\\n$.randstr = l => maprg(l, () => floor(random() * 0x0fff + 0x2000))\\n  .map(v => String.fromCharCode(v)).join(\\"\\")\\nlet font = `normal 16px consolas`, test = () => {\\n  const s = randstr(5), wr = rtw(s, font), w = tw(s, font)\\n  const r = abs(wr - w) < 0.1, eq = w > wr ? \\">\\" : w < wr ? \\"<\\" : \\"=\\", sp = style(span(s), {display:\\"inline-block\\"})\\n  const i = li(`${bs(r)}，测试字符串：\\"`, sp, `\\"，使用缓存/直接测量：${w.toFixed(1)} ${eq} ${wr.toFixed(1)}`); wtcount(r)\\n  !r ? wrong.append(i) : elm(right, {child:[i],diff:true})\\n  const dw = sp.getBoundingClientRect().width.toFixed(1)\\n  elm(i, {child:`，从DOM测量：${dw}，相等：${bs(dw===wr.toFixed(1))}`})\\n  b ? id = setNow(test) : 0\\n}, b = true, id, wrong = ul(), right = ul(), ts = 0, suc = 0\\nconst rsty = {lineHeight:20, fontFamily:`consolas`, fontSize:16}\\nstyle(wrong, rsty), style(right, rsty)\\nconst toggle = () => ((b = !b) ? test() : clearNow(id),\\n  bt1.innerText = (b ? \\"暂停\\" : \\"启动\\"))\\nconst clear = () => right.innerText = wrong.innerText = \\"\\"\\nconst bt1 = dom({tag:\\"button\\", onclick:toggle})\\nconst bt2 = dom({tag:\\"button\\", child:\\"清除\\", onclick:clear})\\nconst count = span(), wtcount = (r = false, s = r ? ++suc : suc, i = ts++) =>\\n  count.innerText = ` 已测试：${s}/${i}次，正确率：${((s/i)*100).toFixed(1)}%`\\nelm(rs6, {child: [\\n  \\"随机生成一些测试，确认使用缓存的textwidth和原本的measureText输出的结果一致：\\",\\n  br(), bt1, bt2, count, wrong, right]})\\ntoggle(), wtcount(0,0,0)\\n}), $.rs6 = dom(), br(),\\n\\"经过上面的验证，可以发现：分别测量每个字符的宽度再相加并不等于直接测量的结果。\\", br(),\\n\\"对于这个状况，我有一些观察：\\",\\nul(li(\\"如果为每个字符生成一个单独的span，将span的长度指定为单个字符的长度，就可以使用分开测量再相加的策略了。\\"),\\n   li(\\"经测试，canvas和dom测量得到的结果并不完全一致，疑似是fallback的字体不一致，这个问题还需要继续研究。\\"),\\n   li(\\"如果使用将文本作为一个整体测量的策略，那么至少还需要思考如何最小化对textwidth的调用。\\", br(),\\n      \\"（因为这是一个相对慢的函数）\\", br(),\\n      \\"这方面可以观察一下vscode的行为：\\",\\n      ul(li(\\"vscode中不管文本内容为何，光标的位置都是正确的。\\", br(),\\n            \\"点击某个位置，光标移动到的字符位置也是正确的。\\", br(),\\n            \\"（即使在整个文本编辑器都被transform样式缩放的情况下，光标的位置也是总是正确的）\\"),\\n         li(\\"如果使用一些多个字符合成的emoji如👨🏿‍🔧，vscode的自动换行会发生得非常早。\\", br(),\\n            \\"此时如果选择一行文本，可以在状态栏的右下角看到，选择出的字符数量远大于看起来的字符数量。\\"),\\n         li(\\"和上一条相同的情况，在行之间切换光标时，光标并不是按视觉位置在移动，而是移动到具有相同字符数的位置。\\", br(),\\n            \\"值得注意的是，这个位置和选择时查看到的字符数量又有所不同。\\", br(),\\n            \\"（在从15个和👨🏿‍🔧类似字符构成的行，移动到全部为英文字母的行中时，对应的位置是30，选择的字符数则为65）\\"),\\n        ),\\n      \\"根据这些现象，可以大概想象vscode的实现：\\",\\n      ul(li(\\"对于光标位置，vscode总是使用类似canvas测量的方法。\\"),\\n         li(\\"对于换行位置，全部使用canvas测量就太慢了，因此用字符数量作为换行的依据。\\"),\\n         li(\\"对于在行间切换光标，只能说是和字符数量相关，但具体怎么实现的暂时不清楚。\\"),\\n        ),\\n     ),\\n  ), br(),\\n\\"接着尝试修复canvas测量与dom测量不完全相同的问题：\\",\\ncode(() => {}),\\nbr(), \\"然后将测量函数与实际的文本编辑器结合起来：\\", code(() => {}),\\nbr(), \\"关于光标的另一个问题是如何获取鼠标对应的文本位置。\\", br(),\\n\\"由于我们已经知道如何计算固定文本的长度了，因此可以使用二分搜索多次查询字符串长度，从而得到光标的实际位置，实现如下：\\",\\ncode(() => {}), dom({class:\\"spbar\\"}), \\"真jr麻烦，不写了。\\",br(),\\nbr(), \\"即使我把canvas测量正确实现了，后面的工作也仍然挺麻烦的，关键是，这些工作现阶段的收益不是那么大。\\",br(),\\n\\"但是文本编辑器还是要有的，拿textarea改改样式得了，下面改为研究如何把textarea封装为一个自定义标签。\\", dom({class:\\"spbar\\"}),\\n\\"\\"\\n]})"},{"v":"style(document.documentElement, {width:\\"50%\\"}), style(document.body, {margin:8})\\nconst mktag = t => $[t] = (...a) => dom({tag:t, child:a}), lh = 20\\n\\"h2 p br pre b ul ol li span div\\".split(\\" \\").forEach(mktag)\\n$.ta = (v = \\"\\") => dom({ tag: \\"textarea\\", spellcheck: false, value: v })\\n$.code = (v = \\"\\", e = true) => (\\n  isfct(v) ? (e ? setTimeout(v) : 0, v = fct2str(v)): 0, dom({ class: \\"code\\", innerText: v }))\\ncss(\\".spbar\\", {width:\\"calc(100% - 2em)\\", margin:\\"1em\\", height:1, backgroundColor:\\"black\\"})\\n\\nconst codefont = { lineHeight: lh, fontSize: \\"1em\\", fontFamily: \\"consolas\\", whiteSpace: \\"pre-wrap\\" }\\ncss(\\".code, .test\\", codefont, { background:\\"#1d191d\\", color:\\"#cbd3d2\\"},\\n  { margin: \\"0.2em 0\\", padding: \\"0.2em 0\\", paddingLeft: \\"2em\\" })\\ncss(\\".accident\\", {color:\\"red\\"})\\nstyle(document.body, { margin: \\"1em\\" }); css(\\"ul, ol\\", { margin: 0 })\\n\\nelm(document.body, {child:[h2(\\"升级文学编程编辑器\\")]})"},{"v":"style(document.documentElement, {width:\\"50%\\"}), style(document.body, {margin:\\"1em\\"})\\nconst mktag = t => $[t] = (...a) => dom({tag:t, child:a})\\n\\"h2 p br pre b\\".split(\\" \\").forEach(mktag)\\nconst testtext = ``\\nelm(document.body, {child:[\\nh2(\\"正则表达式\\"), \\"一个简易的正则测试环境\\"]})"},{"v":"style(document.documentElement, {width:\\"50%\\"}), style(document.body, {margin:\\"1em\\"})\\nconst mktag = t => $[t] = (...a) => dom({tag:t, child:a})\\n\\"h2 p br pre b\\".split(\\" \\").forEach(mktag)\\nconst onclick = () => {\\n  const r = initspeech2text(), lang = \\"zh-CN\\" // 修改这个字符串为zh-CN可以识别中文\\n  assign(r, { lang, interimResults: true, maxAlternatives: 1 })\\n  const s = () => trycatch(() => ($.tmp = dom({}, document.body), r.start()))\\n  const onresult = e => tmp.innerText = e.results[0][0].transcript\\n  assign(r, { onend: s, onresult }), s() }\\nelm(document.body, {child:[\\nh2(\\"一个简单的语音识别的例子\\"), \\"（**并非文章的主要内容**）\\",\\ndom({tag:\\"button\\", child:\\"点我开始语音识别\\", onclick }), br(),\\n\\"下面的内容是使用js的toString功能拿到的函数源码，也就是说实际执行的代码与我展示的代码的总是一致的：\\",\\npre(fct2str(onclick)), \\"由于一些实现上的原因，同时存在两个SpeechRecognition对象的话会导致页面非常卡顿，所以我在编辑器里先实现了一个initspeech2text函数，它会返回一个公用的SpeechRecognition对象，其余部分就和一般的js完全一致了。\\", br(), br(),\\n\\"语音识别出的内容显示在这里：\\"]})"},{"v":"style(document.documentElement, {width:\\"50%\\"}), style(document.body, {margin:\\"1em\\"})\\ncss(\\"ul, ol\\", {margin:0, paddingLeft:\\"2em\\"})\\nconst mktag = t => $[t] = (...a) => dom({tag:t, child:a})\\n\\"h2 p br pre b\\".split(\\" \\").forEach(mktag)\\nconst updvoice = () => $.voices = s.getVoices()\\nconst s = assign(speechSynthesis, { onvoiceschanged: updvoice })\\nconst speak = t => (s.cancel(), s.speak(assign(\\n  new SpeechSynthesisUtterance(t), { onerror: log, voice: voices[vi] })))\\nupdvoice(); const vs={}; voices.forEach((v, i) => (vs[v.lang]??=[]).push((v.i = i, v)))\\nelm(document.body, {child:[ h2(\\"一个简单的文本朗读的例子\\"),\\n  \\"（**并非文章的主要内容**）使用speak函数朗读文本，可用的语音列表：\\", br(), $.ll=dom()]})\\nconst item = v => dom({ tag: \\"li\\", child: `${v.i}: ${v.name}` }); forin(vs, (v, k) =>\\n  elm(ll, { child: [br(), k + \\": \\", dom({ tag: \\"ul\\", child: v.map(item) })] }))\\n\\nconst vi = 19 // 用这个序号选择语音\\nspeak(``) // 想说的话写在这里"}]}'
store.def(preload)

const fct2str = (f, s = String(f)) => {
  const t = s.slice(s.indexOf("{") + 1, s.lastIndexOf("}"))
  const a = t.split(/\r?\n/); if (a[0] === "" && a.length > 1) a.shift()
  const n = a[0].match(/^[\s]+/)?.[0].length ?? 0
  return a.map(v => v.slice(n)).join("\r\n").trim()
}

const lh = 18, setth = t => style(t, { height: t.value.split(/\r?\n/).length * lh })
const editor = d => {
  let sdbx, r = dom({ style: { display: "flex" } }), onkeydown = e =>
    e.key.toLowerCase() === "s" && (e.ctrlKey || e.altKey) ? (e.preventDefault(), upd())
      : e.key.toLowerCase() === "n" && e.altKey ? splice(d.i + 1, 0, { v: "" })
        : e.key.toLowerCase() === "w" && e.altKey ? splice(d.i, 1) : 0
  const upd = () => trycatch(() => (d.v = t.value, save(), refresh(),
    style(t, { color: "" })), e => (style(t, { color: "red" }), panic(e)))
  const t = dom({ tag: "textarea", value: d.v, onkeydown })
  elm(t, { oninput: () => setth(t), spellcheck: false })
  style(t, { resize: "none", width: "calc(50% - 6px)", lineHeight: lh })
  style(t, { whiteSpace: "pre", overflow: "hidden", fontFamily: "consolas, courier" })
  const extra = { fct2str, preload }
  const refresh = () => (sdbx?.destroy(), sdbx = sandbox(assign(scope($), { extra })),
    r = elm(r, { child: [t, sdbx.document.documentElement], diff: true }),
    Function("$", `with($){\n${d.v}\n}`)(sdbx))
  setth(t), setTimeout(refresh), d.d = r; return d
}

$.save = () => store.set(gsl, data.map(({ v }) => ({ v })))
$.sync = () => elm(editors, { child: data.map(({ d }) => d), diff: true })
$.splice = (s, c, ...a) => (data.splice(s, c, ...a.map(editor)),
  data.length > 0 ? 0 : data.push(editor({ v: "" })),
  forrg(data.length, i => data[i].i = i), sync())
const gsl = "global-state-location"; store.get(gsl).then(v => (
  body.append($.editors = dom()), $.data = [], splice(0, 0, ...v ?? [])))